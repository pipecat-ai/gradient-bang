
# Gradient Bang RPC & Event Reference (Client View)

This guide is organized from the client programmer’s perspective. It enumerates every JSON message the client sends to the Gradient Bang WebSocket server, the exact structure of the replies the server returns, and the push events the client can subscribe to.

All traffic flows through a single WebSocket endpoint (`ws://<host>/ws`). Every message is a JSON object. Requests sent by the client always include `"type": "rpc"`. Push events emitted by the server have `"frame_type": "event"`. Every reply (success or failure) echoes the `id` supplied by the client so in-flight requests can be matched with their responses.

---

## 1. Shared Payload Structures

Several RPC replies and server events reuse the same nested payload shapes. The sections below spell them out so you can interpret every field without chasing the schema.

### 1.1 Character Status Object
Used by `join`, `move`, `my_status`, and the `status.update` / `status.init` events.

```json
{
  "name": "TraderP",             // display name / character id
  "sector": 5,                     // current sector number
  "last_active": "2025-09-21T18:05:00.000000Z",
  "ship": {
    "ship_type": "kestrel_courier",
    "ship_name": "Kestrel Courier",
    "cargo": {
      "fuel_ore": 12,
      "organics": 4,
      "equipment": 0
    },
    "cargo_capacity": 40,
    "cargo_used": 16,
    "warp_power": 14,
    "warp_power_capacity": 20,
    "shields": 12,
    "max_shields": 20,
    "fighters": 40,
    "max_fighters": 100,
    "credits": 15250
  },
  "sector_contents": {
    "port": {
      "code": "BSS",
      "last_seen_prices": {
        "fuel_ore": 25,
        "organics": 10,
        "equipment": 40,
        "warp_power_depot": {
          "price_per_unit": 2,
          "note": "Special warp power depot"
        }
      },
      "last_seen_stock": {
        "fuel_ore": 820,
        "organics": 0,
        "equipment": 610
      },
      "observed_at": "2025-09-21T18:04:12.123456Z"
    },
    "planets": [
      { "id": 11, "class_code": "H", "class_name": "Habitable" }
    ],
    "other_players": [
      { "name": "MerchantM", "ship_type": "kestrel_courier" }
    ],
    "adjacent_sectors": [4, 6, 9]
  }
}
```

### 1.2 Sectors Visited Entry (`my_map`)
Each key inside `result.sectors_visited` on a `my_map` reply mirrors the structure written by the knowledge manager.

```json
{
  "sector_id": 5,
  "last_visited": "2025-09-21T18:04:12.123456Z",
  "port_info": {
    "code": "BSS",
    "last_seen_prices": { "fuel_ore": 25, "organics": 10, "equipment": 40 },
    "last_seen_stock": { "fuel_ore": 820, "organics": 0, "equipment": 610 },
    "observed_at": "2025-09-21T18:04:12.123456Z"
  },
  "adjacent_sectors": [4, 6, 9],
  "planets": [
    { "id": 11, "class_code": "H", "class_name": "Habitable" }
  ]
}
```

### 1.3 Local Map Node (`local_map`)
Returned inside `result.node_list` when calling `local_map`.

```json
{
  "id": 5,
  "visited": true,
  "port_type": "BSS",      // derived from the observed port code, null if no port
  "adjacent": [4, 6, 9],
  "is_leaf": false          // true if the sector is a dead-end in the universe map
}
```

`is_leaf` reflects the global universe graph; it is `true` only when the sector has zero or one warp exits in the authoritative world data, so clients do not need to infer this from the truncated local map payload.

---

## 2. Client → Server RPC Messages

Every RPC request shares the envelope shown below:

```json
{
  "type": "rpc",
  "id": "<unique id generated by the client>",
  "endpoint": "<endpoint name>",
  "payload": { ... }
}
```

Each endpoint definition includes the expected request payload fields and a concrete success example. Failures always reply with:

```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "<endpoint name>",
  "ok": false,
  "error": {
    "status": 400,
    "detail": "Reason",
    "code": "optional"
  }
}
```

### `server_status`
- **Request payload:** *(empty object)*
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "server_status",
  "ok": true,
  "result": {
    "name": "Gradient Bang",
    "version": "0.2.0",
    "status": "running",
    "sectors": 5000
  }
}
```

### `join`
- **Request payload:**
  - `character_id` (required)
  - `ship_type` (optional)
  - `credits` (optional)
  - `sector` (optional)
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "join",
  "ok": true,
  "result": { ... character status object ... }
}
```
  Use the structure defined in §1.1 for the `result` object.

### `move`
- **Request payload:**
  - `character_id` (required)
  - `to_sector` (required)
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "move",
  "ok": true,
  "result": { ... character status object with the new sector ... }
}
```

### `my_status`
- **Request payload:**
  - `character_id` (required)
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "my_status",
  "ok": true,
  "result": { ... character status object ... }
}
```

### `my_map`
- **Request payload:**
  - `character_id` (required)
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "my_map",
  "ok": true,
  "result": {
    "sector": 5,
    "sectors_visited": {
      "5": { ... entry from §1.2 ... }
    }
  }
}
```

### `plot_course`
- **Request payload:**
  - `from_sector` (required)
  - `to_sector` (required)
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "plot_course",
  "ok": true,
  "result": {
    "from_sector": 5,
    "to_sector": 12,
    "distance": 4,
    "path": [5, 8, 9, 11, 12]
  }
}
```

### `check_trade`
- **Request payload:**
  - `character_id`
  - `commodity`
  - `quantity`
  - `trade_type`
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "check_trade",
  "ok": true,
  "result": {
    "can_trade": true,
    "price_per_unit": 25,
    "total_price": 250,
    "current_credits": 15250,
    "current_cargo": {
      "fuel_ore": 12,
      "organics": 4,
      "equipment": 0
    },
    "cargo_capacity": 40,
    "cargo_used": 16
  }
}
```
  If trading is not possible, the server returns the same structure with `can_trade: false` and includes an `error` string describing the problem. See `schemas/check_trade_response.schema.json` for the authoritative schema.

### `trade`
- **Request payload:**
  - `character_id`
  - `commodity`
  - `quantity`
  - `trade_type`
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "trade",
  "ok": true,
  "result": {
    "success": true,
    "trade_type": "buy",
    "commodity": "fuel_ore",
    "units": 10,
    "price_per_unit": 25,
    "total_price": 250,
    "new_credits": 15000,
    "new_cargo": { ... cargo map ... },
    "new_prices": { ... latest port pricing ... }
  }
}
```

### `recharge_warp_power`
- **Request payload:**
  - `character_id`
  - `units`
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "recharge_warp_power",
  "ok": true,
  "result": {
    "success": true,
    "units_bought": 5,
    "price_per_unit": 2,
    "total_cost": 10,
    "new_warp_power": 18,
    "warp_power_capacity": 20,
    "new_credits": 14990,
    "message": "Successfully bought 5 warp power units for 10 credits at sector 0 depot"
  }
}
```

### `transfer_warp_power`
- **Request payload:**
  - `from_character_id`
  - `to_character_id`
  - `units`
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "transfer_warp_power",
  "ok": true,
  "result": {
    "success": true,
    "units_transferred": 3,
    "from_warp_power_remaining": 12,
    "to_warp_power_current": 16,
    "message": "Successfully transferred 3 warp power units from TraderP to RunnerQ"
  }
}
```

### `reset_ports`
- **Request payload:** *(empty object)*
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "reset_ports",
  "ok": true,
  "result": {
    "success": true,
    "message": "Reset 50 ports to initial state",
    "ports_reset": 50
  }
}
```

### `regenerate_ports`
- **Request payload:**
  - `fraction` (optional)
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "regenerate_ports",
  "ok": true,
  "result": {
    "success": true,
    "message": "Regenerated 25 ports with 25.0% of max capacity",
    "ports_regenerated": 25,
    "fraction": 0.25
  }
}
```

### `send_message`
- **Request payload:**
  - `character_id`
  - `type`
  - `content`
  - `to_name` (required when `type` is `"direct"`)
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "send_message",
  "ok": true,
  "result": {
    "id": 31415
  }
}
```

### `local_map`
- **Request payload:**
  - `character_id`
  - `max_hops` (optional; legacy hop radius)
  - `max_sectors` (optional; caps total nodes returned, takes precedence over `max_hops` when both are supplied)
  - `current_sector` (optional)
- **Success response:**
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "local_map",
  "ok": true,
  "result": {
    "node_list": [
      {
        "id": 3330,
        "visited": true,
        "port_type": "SBB",
        "adjacent": [0, 3331],
        "is_leaf": false
      },
      {
        "id": 3329,
        "visited": false,
        "port_type": null,
        "adjacent": [3330],
        "is_leaf": true
      }
    ],
    "max_sectors": 15
  }
}
```

---

## 3. Client Control Messages

These commands also use `"type": "rpc"` frames but manage subscriptions/identity rather than world state.

### `subscribe`
```json
{
  "type": "subscribe",
  "id": "<unique id>",
  "event": "status.update",      // or chat.message, warp.transfer, etc.
  "character_id": "TraderP"      // required for character-scoped topics
}
```
Success reply:
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "subscribe",
  "ok": true,
  "result": { "subscribed": "status.update" }
}
```

### `identify`
```json
{
  "type": "identify",
  "id": "<unique id>",
  "character_id": "TraderP",
  "name": "Trader Prime"   // optional alias shown in direct messages
}
```
Success reply:
```json
{
  "frame_type": "rpc",
  "id": "<echoed id>",
  "endpoint": "identify",
  "ok": true,
  "result": { "identified": true }
}
```

Both commands follow the same error format as the game RPCs if something goes wrong (e.g., unknown event name, missing character ID).

---

## 4. Server → Client Push Events

After you subscribe, the server sends push frames shaped like:

```json
{
  "frame_type": "event",
  "event": "status.update",
  "gg-action": "status.update",
  "payload": { ... },
  "character_filter": ["TraderP"]   // present only when the event is targeted
}
```

Below are the payload fields for each event. Unless noted, all listed fields are required.

### `status.update`
- `character_id`
- `name`
- `sector`
- `last_active`
- `ship` (see §1.1)
- `sector_contents` (see §1.1)

### `character.joined`
- `character_id`
- `sector`
- `timestamp`

### `character.moved`
- `character_id`
- `from_sector`
- `to_sector`
- `timestamp`
- `move_type` (`"normal"` or `"teleport"`)

### `chat.message`
- `id`
- `timestamp`
- `type`
- `from_name`
- `content`
- `to_name` (optional)

### `local_map`
- `character_id`
- `sector`
- `max_hops` (optional)
- `max_sectors` (optional)
- `node_list` (array of nodes described in §1.3, each including `is_leaf`)

Example payload (broadcast as an `event` frame, while echoing `gg-action` for compatibility):

```json
{
  "frame_type": "event",
  "event": "local_map",
  "gg-action": "local_map",
  "payload": {
    "character_id": "TraderP",
    "sector": 421,
    "max_sectors": 15,
    "node_list": [
      { "id": 421, "visited": true, "port_type": "BSS", "adjacent": [418, 422], "is_leaf": false },
      { "id": 418, "visited": false, "port_type": null, "adjacent": [421], "is_leaf": true }
    ]
  }
}
```

### `warp.transfer`
- `from_character_id`
- `to_character_id`
- `sector`
- `units`
- `timestamp`

### `warp.purchase`
- `character_id`
- `sector`
- `units`
- `price_per_unit`
- `total_cost`
- `timestamp`

### `tool_call`
- **Top-level:** `tool_name`
- `payload.arguments` – raw arguments dictionary supplied by the LLM (shape varies per tool)

### `tool_result`
- **Top-level:** `tool_name`
- `payload.result` – successful tool response (shape varies per tool)
- `payload.error` – alternative error payload when execution fails

### `task_output`
- `payload.text`
- `payload.task_message_type` (optional; categorises the line, e.g., `"complete"`)

### `task_complete`
- `payload.was_cancelled`
- `payload.via_stop_tool`

### `port.reset`
- `ports_reset`
- `timestamp`

### `port.regenerated`
- `ports_regenerated`
- `fraction`
- `timestamp`

### `status.init`
- `status` (complete character status object; see §1.1)
- `map_data` (optional; `null` or a map snapshot as defined in §1.2)

Example:
```json
{
  "frame_type": "event",
  "event": "status.init",
  "gg-action": "status.init",
  "payload": {
    "status": { ... character status object ... },
    "map_data": { ... map snapshot ... }
  }
}
```

---

## 5. Error Handling Recap

- Any RPC failure (including `subscribe`/`identify`) produces a reply with `ok: false` and an `error` object. The Python `AsyncGameClient` raises `RPCError(endpoint, status, detail, code)` so application code can surface or recover gracefully.
- Push events never carry `error` fields. If a subscription fails, the client learns about it from the RPC error response to the `subscribe` call.

With this reference you can construct every client message, know what to expect back, and consume each server-initiated event confidently. For exhaustive JSON Schema definitions, see `docs/server-events-schema.md`.
## Toll garrisons and the `pay` combat action

- Toll-mode garrisons now maintain a `toll_balance`. When a player pays the toll during combat, the credits are debited from the payer and banked on the garrison. The owner recovers the balance by collecting or redeploying their fighters; victors receive the balance automatically when the garrison is destroyed.
- The `combat.action` RPC accepts a new `"action": "pay"` value. On success the response payload includes `"pay_processed": true`; if the player lacks the required credits, `pay_processed` is `false` and the turn reverts to a brace with a human-readable `message`.
- When toll fighters are paid they immediately brace for the remainder of the encounter. If the same round also resolves their attack while every other participant braces, the round result is the new terminal state `"toll_satisfied"`.
