<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Local Map (Standalone)</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b0b0b; color:#e5e7eb; }
      .wrap { max-width: 980px; margin: 18px auto; padding: 0 12px; }
      .row { display:flex; gap:12px; align-items:end; flex-wrap:wrap; }
      .card { background:#121212; border:1px solid #232323; border-radius:10px; padding:12px; }
      label { display:block; font-size:12px; opacity:.75; margin-bottom:4px; }
      input, textarea { background:#0f0f0f; color:#e5e7eb; border:1px solid #2a2a2a; border-radius:8px; padding:8px; width:100%; }
      textarea { height: 148px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
      button { background:#1f2937; color:#e5e7eb; border:1px solid #2b2b2b; border-radius:8px; padding:8px 12px; cursor:pointer; }
      button:hover { background:#263042; }
      svg { width:100%; height:560px; display:block; background: radial-gradient(1000px 400px at 50% 40%, #0f1012 0%, #0b0b0b 60%); border:1px solid #222; border-radius:12px; }
      .legend { display:flex; gap:10px; align-items:center; font-size:12px; opacity:.85; }
      .dot { width:12px; height:12px; border-radius:9999px; display:inline-block; border:1px solid #1f1f1f; }
      .dot.gray { background:#b0bec5; }
      .dot.red { background:#ef9a9a; }
      .dot.yellow { background:#ffd54f; }
      .muted { opacity:.7; }
      .small { font-size:12px; }
      .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
      @media (min-width: 900px) { .grid { grid-template-columns: 1fr 300px; } }
    </style>
    
  </head>
  <body>
    <div class="wrap">
      <h2 style="margin:6px 0 12px 0;">Local Map (Standalone SVG)</h2>
      <div class="grid">
        <div class="card">
          <svg id="map" viewBox="0 0 800 560">
            <defs>
              <marker id="arrow-end" markerUnits="userSpaceOnUse" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="12" markerHeight="12" orient="auto-start-reverse">
                <path d="M 0 0 L 12 6 L 0 12 z" fill="#9aa0a6"></path>
              </marker>
            </defs>
            <g id="viewport">
              <g id="rings"></g>
              <g id="edges"></g>
              <g id="nodes"></g>
            </g>
          </svg>
          <div class="row" style="justify-content:space-between;margin-top:8px;">
            <div class="legend">
              <span class="dot yellow"></span> current
              <span class="dot gray" style="margin-left:10px"></span> visited
              <span class="dot red" style="margin-left:10px"></span> seen-only
              <span class="muted" style="margin-left:10px">two-way has arrows at both ends</span>
            </div>
            <div class="small muted">Tip: paste JSON or fetch from /api/local_map</div>
          </div>
        </div>
        <div class="card">
          <div class="row" style="align-items:flex-start;">
            <div style="flex:1 1 120px;">
              <label>Center Sector</label>
              <input id="center" type="number" value="0" />
            </div>
            <div style="flex:1 1 120px;">
              <label>Max Hops</label>
              <input id="hops" type="number" value="3" />
            </div>
            <div style="flex:1 1 180px; display:flex; gap:8px; align-items:center;">
              <input id="useWorld" type="checkbox" checked />
              <label for="useWorld" style="margin:0;">Use world data (global)</label>
            </div>
          </div>
          <div class="row" style="margin-top:8px;">
            <button id="fetchBtn">Fetch From /api/local_map</button>
          </div>
          <div class="row" style="margin-top:6px; align-items:center; gap:8px;">
            <button id="prevBtn">◀ Prev</button>
            <button id="randomBtn">Random Center</button>
            <button id="nextBtn">Next ▶</button>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <label class="small" style="margin:0;">Min separation (px)</label>
            <input id="minSep" type="range" min="16" max="64" step="1" value="48" style="width:160px;" />
            <span id="minSepVal" class="small muted">48</span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <label class="small" style="margin:0;">Child arc (°)</label>
            <input id="cohesionArc" type="range" min="10" max="120" step="1" value="80" style="width:160px;" />
            <span id="cohesionArcVal" class="small muted">80</span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <input id="capMode" type="checkbox" checked />
            <label for="capMode" class="small" style="margin:0;">Node render max</label>
            <input id="maxNodes" type="number" min="5" max="500" step="1" value="25" style="width:80px; margin-left:8px;" />
            <span class="small muted">(auto-calc hops)</span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <span class="small">Nodes rendered:&nbsp;<strong id="nodeCount">0</strong></span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center; gap:8px;">
            <input id="bendChords" type="checkbox" checked />
            <label for="bendChords" class="small" style="margin:0;">Bend long chords (experimental)</label>
          </div>
          <div class="row" style="margin-top:6px; align-items:center; gap:8px;">
            <input id="autoExpand" type="checkbox" checked />
            <label for="autoExpand" class="small" style="margin:0;">Auto-expand to satisfy spacing</label>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <label class="small" style="margin:0;">Kick for overlaps (px)</label>
            <input id="kick" type="range" min="0.5" max="6" step="0.5" value="1.5" style="width:160px;" />
            <span id="kickVal" class="small muted">1.5</span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <label class="small" style="margin:0;">Expand aggressiveness</label>
            <input id="expandGain" type="range" min="0.5" max="2.0" step="0.1" value="1.0" style="width:160px;" />
            <span id="expandGainVal" class="small muted">1.0</span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center; gap:8px;">
            <label class="small" style="margin:0;">Max expand steps</label>
            <input id="maxExpandSteps" type="number" min="0" max="12" step="1" value="6" style="width:80px;" />
            <label class="small" style="margin-left:12px;">Expand anchor</label>
            <select id="expandAnchor" style="flex:1 1 auto;">
              <option value="centroid" selected>centroid</option>
              <option value="center">current center sector</option>
            </select>
          </div>
          <div class="row" style="margin-top:6px; align-items:center; gap:8px;">
            <label class="small" style="margin:0;">Debug IDs</label>
            <input id="debugIds" type="text" value="1462,1101,1363,3770" style="flex:1 1 auto;" />
            <button id="logPosBtn">Log positions</button>
          </div>
          <div style="margin-top:10px;">
            <label>JSON Input (node_list or full response)</label>
            <textarea id="json"></textarea>
          </div>
          <div style="margin-top:8px;" class="small muted">
            Expected shape: { "node_list": [ { "id": 123, "visited": true, "port_type": "SSS", "adjacent": [124, 200] }, ... ] }
          </div>
        </div>
      </div>
    </div>

    <script>
      // --- Graph helpers (no deps) ---
      const TAU = Math.PI * 2;
      const FAN_ANGLE_DEG = 40; // cap child fan to keep children close to parent
      const FAN_GAP_RAD = 0.05; // small gap between adjacent parent fans to avoid overlap
      const NODE_R = 10;        // node circle radius (px)
      function UI_MIN_NODE_DIST(){
        const el = document.getElementById('minSep');
        const v = el ? parseFloat(el.value||'28') : 28;
        const span = document.getElementById('minSepVal'); if (span) span.textContent = String(Math.round(v));
        return v;
      }
      function UI_COHESION_ARC(){
        const el = document.getElementById('cohesionArc');
        const v = el ? parseFloat(el.value||'50') : 50;
        const span = document.getElementById('cohesionArcVal'); if (span) span.textContent = String(Math.round(v));
        return v;
      }
      function UI_AUTO_EXPAND(){
        const el = document.getElementById('autoExpand');
        return !!(el && el.checked);
      }
      function UI_KICK(){
        const el = document.getElementById('kick');
        const v = el ? parseFloat(el.value||'1.5') : 1.5;
        const span = document.getElementById('kickVal'); if (span) span.textContent = String(v.toFixed(1));
        return v;
      }
      function UI_EXPAND_GAIN(){
        const el = document.getElementById('expandGain');
        const v = el ? parseFloat(el.value||'1.0') : 1.0;
        const span = document.getElementById('expandGainVal'); if (span) span.textContent = String(v.toFixed(1));
        return v;
      }
      function UI_MAX_EXPAND_STEPS(){
        const el = document.getElementById('maxExpandSteps');
        return el ? parseInt(el.value||'6', 10) : 6;
      }
      function UI_EXPAND_ANCHOR(){
        const el = document.getElementById('expandAnchor');
        return (el && el.value==='center') ? 'center' : 'centroid';
      }
      // No sibling cohesion or ring cohesion in the per-parent ring layout
      function buildUndirected(nodes) {
        const ids = new Set(nodes.map(n => n.id));
        const u = new Map();
        for (const n of nodes) {
          if (!u.has(n.id)) u.set(n.id, new Set());
          for (const t of n.adjacent || []) {
            if (!ids.has(t)) continue;
            if (!u.has(t)) u.set(t, new Set());
            u.get(n.id).add(t);
            u.get(t).add(n.id);
          }
        }
        return u;
      }

      function bfsRings(center, undirected) {
        if (!undirected.has(center)) undirected.set(center, new Set());
        const dist = new Map([[center, 0]]);
        const q = [center];
        while (q.length) {
          const cur = q.shift();
          const d = dist.get(cur);
          for (const nb of undirected.get(cur) || []) {
            if (!dist.has(nb)) { dist.set(nb, d + 1); q.push(nb); }
          }
        }
        return dist;
      }

      function toPairs(nodes) {
        const idToNode = new Map(nodes.map(n => [n.id, n]));
        const map = new Map();
        for (const n of nodes) {
          for (const t of n.adjacent || []) {
            if (!idToNode.has(t)) continue;
            const a = Math.min(n.id, t), b = Math.max(n.id, t);
            const key = a + '-' + b;
            const rec = map.get(key) || { a, b, hasAB:false, hasBA:false };
            if (n.id === a) rec.hasAB = true; else rec.hasBA = true;
            map.set(key, rec);
          }
        }
        return Array.from(map.values());
      }

      function buildRings(nodes, centerId) {
        const undirected = buildUndirected(nodes);
        const dist = bfsRings(centerId, undirected);
        const rings = new Map();
        for (const n of nodes) {
          if (!dist.has(n.id)) continue;
          const d = dist.get(n.id);
          if (!rings.has(d)) rings.set(d, []);
          rings.get(d).push(n.id);
        }
        return { undirected, dist, rings };
      }

      function chooseParents(nodes, undirected, dist) {
        const parent = new Map();
        const children = new Map();
        const byRing = new Map();
        for (const [id,d] of dist.entries()) {
          if (!byRing.has(d)) byRing.set(d, []);
          byRing.get(d).push(id);
        }
        for (const [k, ids] of byRing) ids.sort((a,b)=>a-b);
        for (let k=1; byRing.has(k); k++) {
          const prev = byRing.get(k-1) || [];
          const load = new Map(prev.map(p=>[p, (children.get(p)||[]).length]));
          for (const u of byRing.get(k)) {
            const cands = Array.from(undirected.get(u)||[]).filter(v => dist.get(v) === k-1);
            cands.sort((a,b)=> (load.get(a)||0) - (load.get(b)||0) || a-b);
            const p = cands.length ? cands[0] : prev[0];
            parent.set(u,p);
            const arr = children.get(p)||[]; arr.push(u); children.set(p,arr);
            load.set(p,(load.get(p)||0)+1);
          }
        }
        return { parent, children };
      }

      function computeSubtreeSizes(root, children) {
        const size = new Map();
        const stack = [root];
        const order = [];
        while (stack.length) { const u = stack.pop(); order.push(u); (children.get(u)||[]).forEach(v=>stack.push(v)); }
        for (let i=order.length-1; i>=0; i--) {
          const u = order[i];
          let s = 1;
          for (const v of (children.get(u)||[])) s += size.get(v)||1;
          size.set(u, s);
        }
        return size;
      }

      function assignWedges(root, children, size) {
        const start = new Map();
        const end = new Map();
        const angle = new Map();
        function rec(u, a0, a1) {
          start.set(u,a0); end.set(u,a1); angle.set(u,(a0+a1)/2);
          const ch = (children.get(u)||[]).slice();
          if (!ch.length) return;
          ch.sort((x,y)=> (size.get(y)-size.get(x)) || (x-y));
          const total = ch.reduce((acc,v)=>acc+(size.get(v)||1),0);
          let cur = a0;
          for (const v of ch) {
            const span = (a1-a0) * ((size.get(v)||1)/total);
            rec(v, cur, cur+span);
            cur += span;
          }
        }
        rec(root, 0, TAU);
        return { start, end, angle };
      }

      function refineByBarycenter(root, children, size, dist, undirected, wedges) {
        const { start, end, angle } = wedges;
        function neighborsInPrevRing(u) {
          const k = dist.get(u);
          const preds = [];
          for (const nb of (undirected.get(u)||[])) if (dist.get(nb) === k-1) preds.push(nb);
          return preds;
        }
        function rec(u) {
          const ch = (children.get(u)||[]).slice();
          if (ch.length === 0) return;
          const a0 = start.get(u), a1 = end.get(u);
          // Compute barycenter of previous-ring neighbors (mostly the parent)
          const scored = ch.map(v => {
            const preds = neighborsInPrevRing(v);
            if (preds.length === 0) return { v, score: angle.get(u) };
            const s = preds.reduce((acc,p)=>acc + (angle.get(p)||angle.get(u)||0), 0) / preds.length;
            return { v, score: s };
          });
          scored.sort((a,b)=> a.score - b.score || (a.v - b.v));
          const total = ch.reduce((acc,v)=>acc+(size.get(v)||1),0);
          let cur = a0;
          for (const {v} of scored) {
            const span = (a1-a0) * ((size.get(v)||1)/total);
            start.set(v, cur); end.set(v, cur+span); angle.set(v, (cur + cur+span)/2);
            cur += span;
            rec(v);
          }
        }
        rec(root);
      }

      function enforceParentFan(root, children, size, dist, undirected, wedges) {
        const { start, end, angle } = wedges;
        // Process ring by ring so adjacent parents don't overlap their fans
        const ringMap = new Map();
        for (const [id, k] of dist.entries()) {
          if (!ringMap.has(k)) ringMap.set(k, []);
          ringMap.get(k).push(id);
        }
        for (let k = 1; ringMap.has(k); k++) {
          const parents = ringMap.get(k-1) || [];
          const orderedParents = parents
            .slice()
            .sort((a,b)=> (angle.get(a)||0) - (angle.get(b)||0));
          if (orderedParents.length === 0) continue;
          // Build non-overlapping fans around each parent center, constrained by neighbors
          const centers = orderedParents.map(p => (angle.get(p)||0));
          const caps = orderedParents.map(()=> (FAN_ANGLE_DEG * Math.PI)/180);
          // Compute available arc between parent i and i+1 cyclically
          const arc = (i,j) => {
            const a = centers[i], b = centers[j];
            return (b - a + TAU) % TAU;
          };
          const leftAvail = new Array(orderedParents.length).fill(0);
          const rightAvail = new Array(orderedParents.length).fill(0);
          for (let i=0;i<orderedParents.length;i++) {
            const prev = (i-1+orderedParents.length) % orderedParents.length;
            const next = (i+1) % orderedParents.length;
            rightAvail[i] = Math.max(0, arc(i,next) - FAN_GAP_RAD);
            leftAvail[i] = Math.max(0, arc(prev,i) - FAN_GAP_RAD);
            const avail = leftAvail[i] + rightAvail[i];
            caps[i] = Math.min(caps[i], avail/2);
          }
          // Place children of each parent inside its fan
          for (let idx=0; idx<orderedParents.length; idx++) {
            const p = orderedParents[idx];
            let ch = (children.get(p)||[]).slice();
            if (!ch.length) continue;
            const c = centers[idx];
            // If there is only one parent on previous ring (center), spread
            // all first-hop children around the full circle for clarity.
            let w = Math.max(0.01, caps[idx]);
            // Bias fan away from closer neighbor (more weight to larger available side)
            const L = leftAvail[idx], R = rightAvail[idx];
            const sideWeight = L + R || 1;
            const skew = (R - L) / sideWeight; // [-1,1] positive -> more room on right
            const bias = (k >= 2 ? 0.6 : 0.25) * skew; // stronger push on deeper rings
            let startA = c - w*(0.5 - bias);
            if (orderedParents.length === 1) {
              w = TAU - FAN_GAP_RAD;
              startA = 0;
            }
            // Sifting within fan: order children by barycenter of their same-ring neighbors
            const angleOf = (id)=> angle.get(id) || 0;
            ch.sort((a,b)=>{
              const score = (x)=>{
                let acc=0, cnt=0;
                for (const nb of (undirected.get(x)||[])) {
                  if (dist.get(nb) === k) { acc += angleOf(nb); cnt++; }
                }
                return cnt? acc/cnt : c;
              };
              return score(a) - score(b);
            });
            const count = ch.length;
            for (let i=0;i<count;i++) {
              const v = ch[i];
              const th = startA + (i+0.5)*(w/count);
              const s = th - (w/(2*count));
              const e = th + (w/(2*count));
              start.set(v, (s+TAU)%TAU); end.set(v, (e+TAU)%TAU); angle.set(v, (th+TAU)%TAU);
            }
          }
        }
      }

      async function layout(nodes, centerId, width, height, opts = {}) {
        const { undirected, dist } = buildRings(nodes, centerId);
        const { parent, children } = chooseParents(nodes, undirected, dist);
        const cx = width/2, cy = height/2;
        const pos = new Map();
        pos.set(centerId, { x: cx, y: cy, theta: 0 });
        const ARC = (UI_COHESION_ARC() * Math.PI)/180;
        const MIN_NODE_DIST = UI_MIN_NODE_DIST();
        const LINK = Math.max(80, MIN_NODE_DIST*2);
        const prefAngle = new Map(); // preferred child angle relative to parent
        function placeChildren(p){
          const kids = (children.get(p)||[]);
          if (!kids.length) return;
          const P = pos.get(p);
          const gp = parent.get(p);
          let baseAng = (gp!=null && pos.has(gp)) ? Math.atan2(P.y - pos.get(gp).y, P.x - pos.get(gp).x) : 0;
          let span, start;
          if (p === centerId) {
            // Root: use full 360° around center for clarity
            span = TAU; start = 0;
          } else {
            span = kids.length>1 ? ARC : 0;
            start = baseAng - span/2;
          }
          kids.forEach((kid,i)=>{
            const ang = (p === centerId)
              ? (kids.length>0 ? (TAU * i / kids.length) : 0)
              : (start + (kids.length>1 ? (span*i/(kids.length-1)) : 0));
            pos.set(kid, { x: P.x + LINK*Math.cos(ang), y: P.y + LINK*Math.sin(ang), theta: ang });
            prefAngle.set(kid, ang);
            placeChildren(kid);
          });
        }
        placeChildren(centerId);

        // Crossing minimization by reordering siblings along each parent's arc
        function segIntersect(a,b,c,d){
          function orient(p,q,r){ return (q.x-p.x)*(r.y-p.y) - (q.y-p.y)*(r.x-p.x); }
          const o1=orient(a,b,c), o2=orient(a,b,d), o3=orient(c,d,a), o4=orient(c,d,b);
          if (o1===0||o2===0||o3===0||o4===0) return false; // skip collinear for robustness
          return (o1>0)!=(o2>0) && (o3>0)!=(o4>0);
        }
        function countCrossingsForOrder(p, order){
          const P = pos.get(p); const kids = order;
          const span = (p===centerId)? TAU : ARC; const baseAng = (p===centerId)? 0 : prefAngle.get(p) || 0;
          const start = (p===centerId)? 0 : baseAng - span/2;
          const tmpPos = new Map();
          kids.forEach((kid,i)=>{
            const ang = (p===centerId)? (kids.length? (TAU*i/kids.length):0) : (start + (kids.length>1? (span*i/(kids.length-1)) : 0));
            tmpPos.set(kid, { x: P.x + LINK*Math.cos(ang), y: P.y + LINK*Math.sin(ang) });
          });
          let segs=[];
          for (const kid of kids){
            for (const nb of (undirected.get(kid)||[])){
              if (nb===p) continue; if (!pos.has(nb)) continue; // only count edges to already-placed nodes
              const A = tmpPos.get(kid); const B = pos.get(nb);
              if (!A||!B) continue; segs.push({a:A,b:B});
            }
          }
          let crossings=0;
          for (let i=0;i<segs.length;i++){
            for (let j=i+1;j<segs.length;j++){
              if (segIntersect(segs[i].a,segs[i].b,segs[j].a,segs[j].b)) crossings++;
            }
          }
          return crossings;
        }
        function minimizeOrder(p){
          const kids = (children.get(p)||[]).slice(); if (kids.length<=1) return;
          // Try exhaustive if small
          let best = kids.slice(); let bestScore = countCrossingsForOrder(p,best);
          if (kids.length<=7){
            function* permute(arr,l){ if(l===arr.length){ yield arr.slice(); return;} for(let i=l;i<arr.length;i++){ [arr[l],arr[i]]=[arr[i],arr[l]]; yield*permute(arr,l+1); [arr[l],arr[i]]=[arr[i],arr[l]]; } }
            for (const ord of permute(kids.slice(),0)){ const s=countCrossingsForOrder(p,ord); if (s<bestScore){ bestScore=s; best=ord.slice(); } }
          } else {
            let improved=true; best = kids.slice();
            while(improved){ improved=false; for(let i=0;i<best.length-1;i++){ const ord=best.slice(); [ord[i],ord[i+1]]=[ord[i+1],ord[i]]; const s=countCrossingsForOrder(p,ord); if (s<bestScore){ bestScore=s; best=ord; improved=true; } } }
          }
          // Reposition by best order
          const P = pos.get(p); const span = (p===centerId)? TAU : ARC; const baseAng = (p===centerId)? 0 : prefAngle.get(p)||0; const start=(p===centerId)?0: baseAng - span/2;
          best.forEach((kid,i)=>{ const ang=(p===centerId)? (best.length? TAU*i/best.length:0) : (start + (best.length>1? (span*i/(best.length-1)) : 0)); pos.set(kid,{ x:P.x+LINK*Math.cos(ang), y:P.y+LINK*Math.sin(ang), theta:ang }); prefAngle.set(kid, ang); });
        }
        // Minimize for all parents breadth-first
        const queue=[centerId]; const seen=new Set([centerId]);
        while(queue.length){ const p=queue.shift(); minimizeOrder(p); for(const c of (children.get(p)||[])){ if(!seen.has(c)){ seen.add(c); queue.push(c);} } }
        function estimatedRadiusFor(n){
          const idw = String(n.id).length * 7; const codew = (n.port_type ? n.port_type.length*6 : 0);
          return NODE_R + 8 + Math.max(idw, codew)/2;
        }
        const radii = new Map(nodes.map(n=>[n.id, estimatedRadiusFor(n)]));
        const idsAll = nodes.map(n=>n.id);
        // Precompute edge list (unique undirected pairs)
        const edges = [];
        for (const u of idsAll){ for (const v of (undirected.get(u)||[])){ if (pos.has(v) && u < v) edges.push([u,v]); } }
        // Precompute tree-based hop distance via BFS on the parent/children tree
        const hop = new Map(); hop.set(centerId, 0);
        const qh=[centerId];
        while(qh.length){ const u=qh.shift(); const d=(hop.get(u)||0)+1; for(const v of (children.get(u)||[])){ hop.set(v,d); qh.push(v);} }

        function segInter(a,b,c,d){
          function orient(p,q,r){ return (q.x-p.x)*(r.y-p.y) - (q.y-p.y)*(r.x-p.x); }
          const o1=orient(a,b,c), o2=orient(a,b,d), o3=orient(c,d,a), o4=orient(c,d,b);
          if (o1===0||o2===0||o3===0||o4===0) return false;
          return (o1>0)!=(o2>0) && (o3>0)!=(o4>0);
        }
        function segHitsCircle(a,b,c,rad){
          const px=b.x-a.x, py=b.y-a.y; const len2=px*px+py*py||1e-6; let t=((c.x-a.x)*px+(c.y-a.y)*py)/len2; if (t<0.1||t>0.9) return false; const x=a.x+t*px, y=a.y+t*py; const dx=c.x-x, dy=c.y-y; return (dx*dx+dy*dy)<=rad*rad;
        }
        // Deterministic tiny jitter direction for coincident pairs
        function hashAngle(a,b){ let s=((a*73856093) ^ (b*19349663))>>>0; return (s%6283185)/1000000.0; }
        // Resolve exact/near-coincident nodes by forcing small, guarded separation
        function resolveCoincident(ids, kick=1.5){
          const bins = new Map();
          for (const id of ids){ const p=pos.get(id); if(!p) continue; const key=p.x.toFixed(3)+","+p.y.toFixed(3); if(!bins.has(key)) bins.set(key, []); bins.get(key).push(id); }
          for (const [_, group] of bins){ if (group.length<=1) continue; const base=group[0]; for(let i=1;i<group.length;i++){ const id=group[i]; const ang = hashAngle(base, id); let amp = kick * (1 + i*0.5); let success=false; for(let tries=0; tries<5; tries++){ const dx=Math.cos(ang)*amp, dy=Math.sin(ang)*amp; const step=guardMove(id, dx, dy); if (Math.abs(step.dx)+Math.abs(step.dy) > 1e-3){ const P=pos.get(id); P.x+=step.dx; P.y+=step.dy; success=true; break; } amp*=1.6; } if(!success){ /* fallback tiny jitter without guard */ const P=pos.get(id); P.x+=Math.cos(ang)*0.5; P.y+=Math.sin(ang)*0.5; } } }
        }
        // Robust spacing helper guarded against crossings
        function safeRepulse(ia, ib, need){
          const A = pos.get(ia), B = pos.get(ib); if (!A||!B) return false;
          let dx=B.x-A.x, dy=B.y-A.y; let d=Math.hypot(dx,dy);
          let ux, uy;
          if (d < 1e-5){ const ang = hashAngle(ia,ib); ux=Math.cos(ang); uy=Math.sin(ang); d=1e-5; }
          else { ux=dx/d; uy=dy/d; }
          if (d >= need) return false;
          const push=(need-d)/2;
          let aStep=guardMove(ia, -ux*push, -uy*push);
          let bStep=guardMove(ib, ux*push, uy*push);
          let moved = false;
          if (Math.abs(aStep.dx)+Math.abs(aStep.dy) > 1e-3){ A.x+=aStep.dx; A.y+=aStep.dy; moved=true; }
          if (Math.abs(bStep.dx)+Math.abs(bStep.dy) > 1e-3){ B.x+=bStep.dx; B.y+=bStep.dy; moved=true; }
          // If still violating and guards clipped moves, try a parent-normal fallback to preserve edges
          function parentNormalKick(id, sign){
            const Pid = parent.get(id); const P = pos.get(Pid); const C = pos.get(id);
            if (!C || !P) return false;
            let tx=C.x-P.x, ty=C.y-P.y; const len=Math.hypot(tx,ty)||1e-6; tx/=len; ty/=len; // tangent
            let nx=-ty, ny=tx; // normal
            // Choose direction that increases separation between A and B
            const s = ((C.x - (A.x+B.x)/2)*nx + (C.y - (A.y+B.y)/2)*ny) >= 0 ? 1 : -1;
            const step=guardMove(id, s*nx*1.2, s*ny*1.2);
            if (Math.abs(step.dx)+Math.abs(step.dy) > 1e-3){ C.x+=step.dx; C.y+=step.dy; return true; }
            return false;
          }
          // Re-evaluate and try fallback kicks up to 2 rounds if still below need
          dx=B.x-A.x; dy=B.y-A.y; d=Math.hypot(dx,dy);
          if (d < need-0.5){
            let any=false;
            any = parentNormalKick(ia, -1) || any;
            any = parentNormalKick(ib, +1) || any;
            if (!any){
              // last resort: tiny jitter kicks
              const anga=hashAngle(ia,ib), angb=hashAngle(ib,ia);
              const ja=guardMove(ia, Math.cos(anga)*0.8, Math.sin(anga)*0.8);
              const jb=guardMove(ib, Math.cos(angb)*0.8, Math.sin(angb)*0.8);
              if (Math.abs(ja.dx)+Math.abs(ja.dy)>1e-3){ const C=pos.get(ia); C.x+=ja.dx; C.y+=ja.dy; any=true; }
              if (Math.abs(jb.dx)+Math.abs(jb.dy)>1e-3){ const C=pos.get(ib); C.x+=jb.dx; C.y+=jb.dy; any=true; }
            }
            moved = moved || any;
          }
          return moved;
        }
        function projectSpacing(idsArr, maxSweeps=20, eps=0.5){
          const arr = idsArr.slice();
          for (let pass=0; pass<maxSweeps; pass++){
            arr.sort(()=>Math.random()-0.5);
            let moved=false; let maxViol=0;
            for (let i=0;i<arr.length;i++){
              for (let j=i+1;j<arr.length;j++){
                const ia=arr[i], ib=arr[j];
                const A=pos.get(ia), B=pos.get(ib); if(!A||!B) continue;
                const need=Math.max(MIN_NODE_DIST, (radii.get(ia)||0)+(radii.get(ib)||0));
                const d=Math.hypot(B.x-A.x,B.y-A.y);
                const viol = Math.max(0, need - d);
                if (viol > eps){ if (safeRepulse(ia, ib, need)) moved=true; }
                if (viol > maxViol) maxViol = viol;
              }
            }
            if (maxViol <= eps) return true; // satisfied
            if (!moved) continue; // try again; guards may open space next pass
          }
          // give up after cap; best effort
          return false;
        }
        function guardMove(id, dx, dy){
          let lam = 0.5; // small step
          const A = pos.get(id); if (!A) return {dx:0,dy:0};
          const nbrs = Array.from(undirected.get(id)||[]);
          outer: while (lam > 1e-3){
            const trial = { x: A.x + lam*dx, y: A.y + lam*dy };
            // Edge-node guard
            for (const n of nbrs){ const N = pos.get(n); if (!N) continue; for (const cId of idsAll){ if (cId===id || cId===n) continue; const C=pos.get(cId); if (!C) continue; if (segHitsCircle(trial,N,C,NODE_R+4)) { lam/=2; continue outer; } } }
            // Edge-edge guard
            for (const n of nbrs){ const N=pos.get(n); if (!N) continue; const a=trial, b=N; for (const [u,v] of edges){ if (u===id||v===id||u===n||v===n) continue; const U=pos.get(u), V=pos.get(v); if (!U||!V) continue; if (segInter(a,b,U,V)) { lam/=2; continue outer; } } }
            break; // safe
          }
          return { dx: lam*dx, dy: lam*dy };
        }

        // --- Projection Solver (inequality spacing + soft springs) ---
        function buildPairsFor(ids){
          const arr = ids.slice(); const pairs=[];
          for (let i=0;i<arr.length;i++){
            for (let j=i+1;j<arr.length;j++) pairs.push([arr[i],arr[j]]);
          }
          return pairs;
        }
        function angleWrap(a){ while(a>Math.PI) a-=TAU; while(a<-Math.PI) a+=TAU; return a; }
        function maxSpacingViolation(ids){
          const pairs = buildPairsFor(ids); let mv=0;
          for (const [ia,ib] of pairs){ const A=pos.get(ia), B=pos.get(ib); if(!A||!B) continue; const need=Math.max(MIN_NODE_DIST, (radii.get(ia)||0)+(radii.get(ib)||0)); const d=Math.hypot(B.x-A.x,B.y-A.y); const v=Math.max(0, need-d); if (v>mv) mv=v; }
          return mv;
        }
        function minScaleFactorToSatisfy(ids, eps=0.5){
          // Distances under uniform dilation about any anchor scale by the same factor f.
          // Minimal f is max over violating pairs of (need+eps)/d.
          const pairs = buildPairsFor(ids); let f = 1.0;
          for (const [ia, ib] of pairs){
            const A=pos.get(ia), B=pos.get(ib); if(!A||!B) continue;
            const need=Math.max(UI_MIN_NODE_DIST(), (radii.get(ia)||0)+(radii.get(ib)||0));
            const d=Math.hypot(B.x-A.x, B.y-A.y);
            if (d + eps < need){ const cand = (need + eps) / Math.max(d, 1e-6); if (cand > f) f = cand; }
          }
          // small cushion to avoid thrashing around exact equality
          return Math.max(1.0, f * 1.002);
        }
        function globalDilation(ids, factor, anchor){
          // Scale around anchor (centroid or selected node); preserves planarity
          let ax, ay;
          if (anchor && Number.isFinite(anchor.x) && Number.isFinite(anchor.y)){
            ax = anchor.x; ay = anchor.y;
          } else {
            let cx=0, cy=0, cnt=0; for (const id of ids){ const P=pos.get(id); if (!P) continue; cx+=P.x; cy+=P.y; cnt++; } if (!cnt) return; ax=cx/cnt; ay=cy/cnt;
          }
          for (const id of ids){ const P=pos.get(id); if (!P) continue; P.x = ax + (P.x - ax)*factor; P.y = ay + (P.y - ay)*factor; }
        }
        function projectionSolver(ids, opts={}){
          const eps = opts.eps ?? 0.5;
          const maxIters = opts.maxIters ?? 8;
          const lenK = opts.springLenK ?? 0.28;  // parent-child length spring
          const angK = opts.springAngK ?? 0.16;  // parent-child angular spring
          const pairs = buildPairsFor(ids);
          function maxViolation(){
            let mv=0; for (const [ia,ib] of pairs){ const A=pos.get(ia), B=pos.get(ib); if(!A||!B) continue; const need=Math.max(MIN_NODE_DIST, (radii.get(ia)||0)+(radii.get(ib)||0)); const d=Math.hypot(B.x-A.x,B.y-A.y); const v=Math.max(0, need-d); if(v>mv) mv=v; } return mv;
          }
          for (let it=0; it<maxIters; it++){
            let moved=false;
            // 1) Enforce spacing via alternating projections
            for (const [ia, ib] of pairs){
              const A=pos.get(ia), B=pos.get(ib); if(!A||!B) continue;
              const need=Math.max(MIN_NODE_DIST, (radii.get(ia)||0)+(radii.get(ib)||0));
              let dx=B.x-A.x, dy=B.y-A.y; let d=Math.hypot(dx,dy);
              if (d >= need - eps) continue;
              let ux, uy;
              if (d < 1e-6){ const ang=hashAngle(ia,ib); ux=Math.cos(ang); uy=Math.sin(ang); d=1e-6; }
              else { ux=dx/d; uy=dy/d; }
              const push=(need-d)/2;
              const aStep=guardMove(ia, -ux*push, -uy*push);
              const bStep=guardMove(ib,  ux*push,  uy*push);
              if (Math.abs(aStep.dx)+Math.abs(aStep.dy)>1e-3){ A.x+=aStep.dx; A.y+=aStep.dy; moved=true; }
              if (Math.abs(bStep.dx)+Math.abs(bStep.dy)>1e-3){ B.x+=bStep.dx; B.y+=bStep.dy; moved=true; }
            }
            // 2) Parent-child soft springs (length + angular preference)
            for (const id of ids){
              const p = parent.get(id); if (p==null) continue; const P=pos.get(p), C=pos.get(id); if(!P||!C) continue;
              // Length spring towards LINK
              let rx=C.x-P.x, ry=C.y-P.y; let rlen=Math.hypot(rx,ry)||1e-6; let ux=rx/rlen, uy=ry/rlen;
              const maxLenStep = Math.max(4, 0.40*LINK);
              let lenDelta=(LINK - rlen)*lenK; if (lenDelta >  maxLenStep) lenDelta =  maxLenStep; if (lenDelta < -maxLenStep) lenDelta = -maxLenStep;
              if (Math.abs(lenDelta)>0.01){ const s=guardMove(id, ux*lenDelta, uy*lenDelta); C.x+=s.dx; C.y+=s.dy; moved = moved || Math.abs(s.dx)+Math.abs(s.dy)>1e-3; rlen = Math.hypot(C.x-P.x, C.y-P.y)||1e-6; rx=C.x-P.x; ry=C.y-P.y; ux=rx/rlen; uy=ry/rlen; }
              // Angle spring towards prefAngle
              const pref = prefAngle.get(id);
              if (pref != null){ const ang = Math.atan2(ry,rx); const diff = angleWrap(pref - ang); if (Math.abs(diff) > 0.002){ const tangent = { x:-uy, y:ux }; let arcStep = diff * angK * rlen; const maxArcStep = Math.max(4, 0.35*LINK); if (arcStep >  maxArcStep) arcStep =  maxArcStep; if (arcStep < -maxArcStep) arcStep = -maxArcStep; const s=guardMove(id, tangent.x*arcStep, tangent.y*arcStep); if (Math.abs(s.dx)+Math.abs(s.dy)>1e-3){ C.x+=s.dx; C.y+=s.dy; moved=true; } } }
            }
            // 3) Re-project spacing after springs (early-exit if clean)
            let mv = maxViolation();
            if (mv <= eps && !moved) break;
          }
        }

        const iters = 28;
        for (let it=0; it<iters; it++){
          let moved=false;
          // Ensure no exact duplicates before each pass
          resolveCoincident(idsAll, UI_KICK());
          // Apply long-chord bending first, then enforce spacing, then springs
          if ((document.getElementById('bendChords')?.checked)){
            for (const [u,v] of edges){
              function pathBetweenNodes(a,b){ const anc=new Set(); let x=a; while(x!=null){ anc.add(x); x=parent.get(x);} let y=b; const down=[]; while(y!=null && !anc.has(y)){ down.push(y); y=parent.get(y);} if(y==null) return [a,b]; const lca=y; const up=[]; x=a; while(x!==lca){ up.push(x); x=parent.get(x);} up.push(lca); return up.concat(down.reverse()); }
              const pathNodes=pathBetweenNodes(u,v); const pathLen=Math.max(0,pathNodes.length-1); if (pathLen<3) continue;
              const U=pos.get(u), V=pos.get(v); if(!U||!V) continue;
              let tu; const pu=parent.get(u); if(pu!=null && pos.has(pu)){ const P=pos.get(pu); tu={x:U.x-P.x,y:U.y-P.y}; } else { tu={x:V.x-U.x,y:V.y-U.y}; }
              const tulen=Math.hypot(tu.x,tu.y)||1e-6; tu.x/=tulen; tu.y/=tulen; let tv; const pv=parent.get(v); if(pv!=null && pos.has(pv)){ const P=pos.get(pv); tv={x:V.x-P.x,y:V.y-P.y}; } else { tv={x:U.x-V.x,y:U.y-V.y}; } const tvlen=Math.hypot(tv.x,tv.y)||1e-6; tv.x/=tvlen; tv.y/=tvlen;
              const cu={x:V.x-U.x,y:V.y-U.y}; const culen=Math.hypot(cu.x,cu.y)||1e-6; const cuh={x:cu.x/culen,y:cu.y/culen}; const colu=Math.abs(cuh.x*tu.x + cuh.y*tu.y), colv=Math.abs((-cuh.x)*tv.x + (-cuh.y)*tv.y); if(colu<=0.9 || colv<=0.9) continue;
              const nu={x:-tu.y,y:tu.x}, nv={x:-tv.y,y:tv.x};
              const mx=(U.x+V.x)/2, my=(U.y+V.y)/2;
              // Global bend side for this chord based on chord normal and path centroid
              let nxChord=-cuh.y, nyChord=cuh.x; let cx=0, cy=0; for(const w of pathNodes){ const W=pos.get(w); cx+=W.x; cy+=W.y; } cx/=pathNodes.length; cy/=pathNodes.length; const dir = ((cx-mx)*nxChord + (cy-my)*nyChord) >= 0 ? 1 : -1;
              const su = dir * ((nu.x*nxChord + nu.y*nyChord)>=0 ? 1 : -1);
              const sv = dir * ((nv.x*nxChord + nv.y*nyChord)>=0 ? 1 : -1);
              const K=24, alpha=0.6;
              // ROI: path nodes + one-hop neighbors
              const roi = new Set(pathNodes); for(const w of pathNodes){ for(const nb of (undirected.get(w)||[])){ roi.add(nb); } }
              const backup = new Map(); for(const idd of roi){ const Pp=pos.get(idd); backup.set(idd,{x:Pp.x,y:Pp.y}); }
              // crossings within ROI
              function roiCrossings(){ let c=0; const arr=[...roi]; const setR=new Set(arr); const eR=edges.filter(([a,b])=> setR.has(a)&&setR.has(b)); for(let i=0;i<eR.length;i++){ const [a,b]=eR[i]; const A=pos.get(a), B=pos.get(b); for(let j=i+1;j<eR.length;j++){ const [c1,d1]=eR[j]; if(a===c1||a===d1||b===c1||b===d1) continue; const C=pos.get(c1), D=pos.get(d1); if(segInter(A,B,C,D)) c++; } } return c; }
              const beforeX=roiCrossings();
              // Endpoint pushes
              let sU=guardMove(u, su*nu.x*K*alpha, su*nu.y*K*alpha); U.x+=sU.dx; U.y+=sU.dy; const Ppu=pos.get(parent.get(u)); if(Ppu){ prefAngle.set(u, Math.atan2(U.y-Ppu.y, U.x-Ppu.x)); }
              let sV=guardMove(v, sv*nv.x*K*alpha, sv*nv.y*K*alpha); V.x+=sV.dx; V.y+=sV.dy; const Ppv=pos.get(parent.get(v)); if(Ppv){ prefAngle.set(v, Math.atan2(V.y-Ppv.y, V.x-Ppv.x)); }
              // Path node pushes
              for(let k=1;k<pathNodes.length-1;k++){ const w=pathNodes[k]; const W=pos.get(w); const prev=pos.get(pathNodes[k-1]), next=pos.get(pathNodes[k+1]); if(!prev||!next) continue; let tx=next.x-prev.x, ty=next.y-prev.y; const tlen=Math.hypot(tx,ty)||1e-6; tx/=tlen; ty/=tlen; let nx=-ty, ny=tx; const t=k/(pathNodes.length-1); const falloff=Math.sin(Math.PI*t); const step=guardMove(w, dir*nx*K*alpha*falloff, dir*ny*K*alpha*falloff); W.x+=step.dx; W.y+=step.dy; const Ppw=pos.get(parent.get(w)); if(Ppw){ prefAngle.set(w, Math.atan2(W.y-Ppw.y, W.x-Ppw.x)); } }
              // ROI projection solve (spacing + local springs)
              projectionSolver([...roi], { maxIters: 4, eps: 0.8, springLenK: 0.22, springAngK: 0.14 });
              const afterX=roiCrossings(); if(afterX>beforeX){ for(const [idd,p] of backup){ const Pp=pos.get(idd); Pp.x=p.x; Pp.y=p.y; } } else { moved=true; }
            }
          }
          // Global projection solve across all nodes (enforce spacing + springs)
          projectionSolver(idsAll, { maxIters: 6, eps: 0.5, springLenK: 0.24, springAngK: 0.16 });
          // If still violated, prefer local dilation of violating clusters over global
          if (UI_AUTO_EXPAND()){
            const epsV = 0.4;
            // Build violating pairs
            const pairs = [];
            for (let i=0;i<idsAll.length;i++){
              for (let j=i+1;j<idsAll.length;j++){
                const ia=idsAll[i], ib=idsAll[j]; const A=pos.get(ia), B=pos.get(ib); if(!A||!B) continue;
                const need=Math.max(UI_MIN_NODE_DIST(), (radii.get(ia)||0)+(radii.get(ib)||0));
                const d=Math.hypot(B.x-A.x,B.y-A.y); if(d + epsV < need) pairs.push([ia,ib,d,need]);
              }
            }
            if (pairs.length){
              // Union-Find clusters from violating pairs
              const parentUF=new Map(); const find=(x)=>{ if(parentUF.get(x)===x) return x; const r=find(parentUF.get(x)); parentUF.set(x,r); return r; };
              const union=(a,b)=>{ const ra=find(a), rb=find(b); if(ra!==rb) parentUF.set(ra,rb); };
              for(const id of idsAll){ parentUF.set(id,id); }
              for(const [a,b] of pairs){ union(a,b); }
              const groups=new Map();
              for(const [a,b] of pairs){ const r=find(a); if(!groups.has(r)) groups.set(r,new Set()); groups.get(r).add(a); groups.get(r).add(b); }
              // Sort clusters by size desc, then apply local dilation
              const clusters=[...groups.values()].sort((A,B)=>B.size-A.size);
              const gain = UI_EXPAND_GAIN();
              let anyLocal=false;
              for(const set of clusters){
                const ids=[...set]; if(ids.length<2) continue;
                // Minimal factor based on internal violating pairs only
                let fNeed=1.0; for(const [a,b,d,need] of pairs){ if(set.has(a)&&set.has(b)){ const cand=(need+epsV)/Math.max(d,1e-6); if(cand>fNeed) fNeed=cand; } }
                fNeed = Math.max(1.0, fNeed*1.002);
                const f = Math.pow(fNeed, Math.max(0.5, Math.min(1.5, gain)));
                if (f<=1.01) continue;
                // Anchor = cluster centroid
                let cx=0, cy=0; for(const id of ids){ const P=pos.get(id); cx+=P.x; cy+=P.y; } cx/=ids.length; cy/=ids.length;
                // Apply guarded local dilation per node
                for(const id of ids){ const P=pos.get(id); const dx=(P.x-cx)*(f-1), dy=(P.y-cy)*(f-1); const step=guardMove(id, dx, dy); P.x+=step.dx; P.y+=step.dy; }
                // ROI: cluster + 1-hop neighbors, re-project locally
                const roi=new Set(ids); for(const id of ids){ for(const nb of (undirected.get(id)||[])){ roi.add(nb); } }
                projectionSolver([...roi], { maxIters: 3, eps: 0.6, springLenK: 0.2, springAngK: 0.12 });
                anyLocal=true;
              }
              moved = moved || anyLocal;
              // As a last resort if many clusters or extreme overlap, do a minimal global dilation
              if(!moved){
                const fNeeded = minScaleFactorToSatisfy(idsAll, epsV);
                const f = Math.pow(fNeeded, Math.max(0.5, Math.min(1.2, gain)));
                if (f > 1.01){ const anchor = (UI_EXPAND_ANCHOR()==='center') ? pos.get(centerId) : null; globalDilation(idsAll, f, anchor); projectionSolver(idsAll, { maxIters: 2, eps: 0.6, springLenK: 0.18, springAngK: 0.12 }); moved=true; }
              }
            }
            // After any expansion (local or global), run a quick global settle to keep strays in check
            if (moved){
              projectionSolver(idsAll, { maxIters: 2, eps: 0.55, springLenK: 0.22, springAngK: 0.14 });
            }
          }
          if (!moved) break;
        }
        return { pos, maxRing: 3 };
      }

      // --- Rendering ---
      async function render(nodes, centerId) {
        const svg = document.getElementById('map');
        const W = svg.viewBox.baseVal.width || 800;
        const H = svg.viewBox.baseVal.height || 560;
        const { pos, maxRing } = await layout(nodes, centerId, W, H, {});
        const ringsG = document.getElementById('rings');
        const edgesG = document.getElementById('edges');
        const nodesG = document.getElementById('nodes');
        const viewport = document.getElementById('viewport');
        ringsG.innerHTML = edgesG.innerHTML = nodesG.innerHTML = '';

        // no global rings; keep group for potential guides

        // edges (tree vs non-tree with curves)
        function line(x1,y1,x2,y2, opts={}){
          const el = document.createElementNS('http://www.w3.org/2000/svg','line');
          el.setAttribute('x1', x1); el.setAttribute('y1', y1); el.setAttribute('x2', x2); el.setAttribute('y2', y2);
          el.setAttribute('stroke', opts.stroke || '#9aa0a6');
          el.setAttribute('stroke-width', opts.strokeWidth || '1.25');
          if (opts.markerStart) el.setAttribute('marker-start', opts.markerStart);
          if (opts.markerEnd) el.setAttribute('marker-end', opts.markerEnd);
          if (opts.opacity) el.setAttribute('opacity', opts.opacity);
          edgesG.appendChild(el);
        }
        function path(d, opts={}){
          const el = document.createElementNS('http://www.w3.org/2000/svg','path');
          el.setAttribute('d', d);
          el.setAttribute('fill','none');
          el.setAttribute('stroke', opts.stroke || '#8fa3ad');
          el.setAttribute('stroke-width', opts.strokeWidth || '1');
          if (opts.markerStart) el.setAttribute('marker-start', opts.markerStart);
          if (opts.markerEnd) el.setAttribute('marker-end', opts.markerEnd);
          if (opts.opacity) el.setAttribute('opacity', opts.opacity);
          edgesG.appendChild(el);
        }

        const pairs = toPairs(nodes).filter(p => pos.has(p.a) && pos.has(p.b));
        function segHitsNode(A,B,C,r){
          const px=B.x-A.x, py=B.y-A.y; const len2=px*px+py*py||1e-6;
          let t=((C.x-A.x)*px+(C.y-A.y)*py)/len2;
          // ignore near endpoints so we don't curve every edge
          if (t < 0.1 || t > 0.9) return false;
          const x=A.x+t*px, y=A.y+t*py; const dx=C.x-x, dy=C.y-y; return (dx*dx+dy*dy)<=r*r;
        }
        function drawEdge(A,B,markerStart,markerEnd){
          // Trim to node boundary so arrowheads are not hidden under node circles
          const dx=B.x-A.x, dy=B.y-A.y; let d=Math.hypot(dx,dy)||1e-6; const ux=dx/d, uy=dy/d;
          const TRIM = NODE_R + 6;
          const As={ x:A.x+ux*TRIM, y:A.y+uy*TRIM };
          const Be={ x:B.x-ux*TRIM, y:B.y-uy*TRIM };
          let worst=null, worstD=Infinity;
          for (const n of nodes){ const id=n.id; if (id===A.id||id===B.id) continue; const C=pos.get(id); if (!C) continue; if (segHitsNode(As,Be,C,NODE_R+3)){ const mx=(As.x+Be.x)/2, my=(As.y+Be.y)/2; const dd=(C.x-mx)**2+(C.y-my)**2; if (dd<worstD){ worstD=dd; worst=C; } } }
          if (!worst){ line(As.x,As.y,Be.x,Be.y,{ stroke:'#9aa0a6', strokeWidth:1.25, markerStart, markerEnd, opacity:0.85 }); return; }
          const mx=(As.x+Be.x)/2, my=(As.y+Be.y)/2; let nx=-(dy/d), ny=(dx/d); const dirx=mx-worst.x, diry=my-worst.y; const s=(dirx*nx+diry*ny)>=0?1:-1; const qx=mx+s*nx*18, qy=my+s*ny*18; const dpath=`M ${As.x} ${As.y} Q ${qx} ${qy} ${Be.x} ${Be.y}`; path(dpath,{ stroke:'#9aa0a6', strokeWidth:1.25, opacity:0.85, markerStart, markerEnd }); }
        for (const e of pairs) {
          const A = pos.get(e.a), B = pos.get(e.b);
          const markerStart = e.hasBA ? 'url(#arrow-end)' : undefined;
          const markerEnd = e.hasAB ? 'url(#arrow-end)' : undefined;
          drawEdge(A,B,markerStart,markerEnd);
        }

        // nodes
        for (const n of nodes) {
          if (!pos.has(n.id)) continue;
          const p = pos.get(n.id);
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circle.setAttribute('cx', p.x); circle.setAttribute('cy', p.y); circle.setAttribute('r', String(NODE_R));
          let fill = n.id === centerId ? '#ffd54f' : (n.visited ? '#b0bec5' : '#ef9a9a');
          circle.setAttribute('fill', fill); circle.setAttribute('stroke','#1f1f1f'); circle.setAttribute('stroke-width','1');
          g.appendChild(circle);
          const t1 = document.createElementNS('http://www.w3.org/2000/svg','text');
          t1.setAttribute('x', p.x); t1.setAttribute('y', p.y - 14); t1.setAttribute('text-anchor','middle');
          t1.setAttribute('font-size','10'); t1.setAttribute('fill','#e0e0e0'); t1.textContent = String(n.id);
          g.appendChild(t1);
          if (n.port_type) {
            const t2 = document.createElementNS('http://www.w3.org/2000/svg','text');
            t2.setAttribute('x', p.x); t2.setAttribute('y', p.y + 18); t2.setAttribute('text-anchor','middle');
            t2.setAttribute('font-size','9'); t2.setAttribute('fill','#9ccc65'); t2.textContent = n.port_type;
            g.appendChild(t2);
          }
          nodesG.appendChild(g);
        }
        // Update node count in UI
        const nodeCountEl = document.getElementById('nodeCount');
        if (nodeCountEl) nodeCountEl.textContent = String(Array.from(pos.keys()).length);

        // Fit to viewport: center + scale to fill, preserving aspect
        let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
        for (const n of nodes){ const p=pos.get(n.id); if (!p) continue; minX=Math.min(minX,p.x-NODE_R); maxX=Math.max(maxX,p.x+NODE_R); minY=Math.min(minY,p.y-NODE_R); maxY=Math.max(maxY,p.y+NODE_R); }
        const bx=(minX+maxX)/2, by=(minY+maxY)/2; const bw=Math.max(1,maxX-minX), bh=Math.max(1,maxY-minY);
        const margin=40; const sx=(W-margin*2)/bw, sy=(H-margin*2)/bh; const s=Math.min(sx,sy,1.8);
        const tx=W/2 - s*bx, ty=H/2 - s*by; document.getElementById('viewport').setAttribute('transform',`translate(${tx},${ty}) scale(${s})`);
      }

      // --- UI wiring ---
      const jsonEl = document.getElementById('json');
      const centerEl = document.getElementById('center');
      const hopsEl = document.getElementById('hops');
      const useWorldEl = document.getElementById('useWorld');

      // Cache player name and world data
      let savedCharacter = null;
      let worldCache = null; // {dirAdj, undAdj, portMap}

      async function loadWorldData() {
        if (worldCache) return worldCache;
        const [uRes, cRes] = await Promise.all([
          fetch('world-data/universe_structure.json'),
          fetch('world-data/sector_contents.json').catch(()=>null)
        ]);
        if (!uRes.ok) throw new Error('Could not load world-data/universe_structure.json');
        const univ = await uRes.json();
        let contents = null;
        if (cRes && cRes.ok) contents = await cRes.json();
        const dir = new Map();
        for (const s of univ.sectors) dir.set(s.id, s.warps.map(w=>w.to));
        const und = new Map();
        for (const [sid, outs] of dir) {
          if (!und.has(sid)) und.set(sid, new Set());
          for (const t of outs) {
            if (!und.has(t)) und.set(t, new Set());
            und.get(sid).add(t); und.get(t).add(sid);
          }
        }
        const portMap = new Map();
        if (contents) for (const s of contents.sectors) portMap.set(s.id, s.port && s.port.code ? s.port.code : null);
        worldCache = { dirAdj: dir, undAdj: und, portMap };
        return worldCache;
      }

      function buildLocalFromWorld(centerId, hops, world) {
        const dist = new Map([[centerId,0]]);
        const q = [centerId];
        while (q.length) {
          const u = q.shift();
          if (dist.get(u) >= hops) continue;
          for (const v of (world.undAdj.get(u) || [])) {
            if (!dist.has(v)) { dist.set(v, dist.get(u)+1); q.push(v); }
          }
        }
        const included = new Set(Array.from(dist.keys()));
        const node_list = [];
        for (const id of Array.from(included).sort((a,b)=>a-b)) {
          const outs = world.dirAdj.get(id) || [];
          node_list.push({ id, visited: true, port_type: world.portMap.get(id) || null, adjacent: outs.filter(t=>included.has(t)) });
        }
        return { node_list };
      }
      // update minSep label on input
      const minSepEl = document.getElementById('minSep');
      // Keep last rendered graph to allow re-render on knob changes
      let lastNodes = null;
      let lastCenter = null;
      const history = [];
      let histIndex = -1;
      function rerenderIfPossible(){ if (lastNodes && lastCenter !== null){ render(lastNodes, lastCenter); } }
      if (minSepEl) minSepEl.addEventListener('input', () => { UI_MIN_NODE_DIST(); rerenderIfPossible(); });
      const cohArcEl = document.getElementById('cohesionArc'); if (cohArcEl) cohArcEl.addEventListener('input', ()=>{ UI_COHESION_ARC(); rerenderIfPossible(); });
      const capModeEl = document.getElementById('capMode'); if (capModeEl) capModeEl.addEventListener('change', fetchAndRender);
      const maxNodesEl = document.getElementById('maxNodes'); if (maxNodesEl) maxNodesEl.addEventListener('input', fetchAndRender);
      const bendEl = document.getElementById('bendChords'); if (bendEl) bendEl.addEventListener('change', rerenderIfPossible);
      const autoExpandEl = document.getElementById('autoExpand'); if (autoExpandEl) autoExpandEl.addEventListener('change', rerenderIfPossible);
      const kickEl = document.getElementById('kick'); if (kickEl) kickEl.addEventListener('input', ()=>{ UI_KICK(); rerenderIfPossible(); });
      const gainEl = document.getElementById('expandGain'); if (gainEl) gainEl.addEventListener('input', ()=>{ UI_EXPAND_GAIN(); rerenderIfPossible(); });
      const maxStepsEl = document.getElementById('maxExpandSteps'); if (maxStepsEl) maxStepsEl.addEventListener('input', rerenderIfPossible);
      const anchorEl = document.getElementById('expandAnchor'); if (anchorEl) anchorEl.addEventListener('change', rerenderIfPossible);
      // Initialize label readouts
      UI_MIN_NODE_DIST(); UI_COHESION_ARC(); UI_KICK(); UI_EXPAND_GAIN();

      async function fetchAndRender(skipHistory=false){
        const centerId = parseInt(centerEl.value || '0', 10);
        const hopsInput = parseInt(hopsEl.value || '3', 10);
        const capMode = document.getElementById('capMode')?.checked;
        const maxNodes = parseInt(document.getElementById('maxNodes')?.value || '25', 10);
        try{
          if (useWorldEl.checked){
            const world = await loadWorldData();
            let hops = hopsInput;
            if (capMode){
              // BFS layer counts from center
              const q=[centerId]; const dist=new Map([[centerId,0]]);
              while(q.length){ const u=q.shift(); for(const v of (world.undAdj.get(u)||[])){ if(!dist.has(v)){ dist.set(v, (dist.get(u)||0)+1); q.push(v);} } }
              const maxLayer = Math.max(...dist.values());
              const layerCounts = Array.from({length:maxLayer+1}, (_,k)=> Array.from(dist.values()).filter(d=>d===k).length);
              let cum=0, safe=0;
              for (let k=0;k<layerCounts.length;k++){ const next=cum+layerCounts[k]; if (next>maxNodes){ break; } cum=next; safe=k; }
              hops = safe; hopsEl.value = String(hops);
            }
            const data = buildLocalFromWorld(centerId, hops, world);
            document.getElementById('json').value = JSON.stringify(data, null, 2);
            lastNodes = data.node_list || []; lastCenter = centerId; await render(lastNodes, lastCenter);
            if (!skipHistory){ history.splice(histIndex+1); history.push(centerId); histIndex = history.length-1; }
          } else {
            if (!savedCharacter) { const c = prompt('Character ID to fetch for:', 'JoePlayer'); if (!c) return; savedCharacter = c; }
            let hops = hopsInput; let finalData=null; let lastData=null; let i=0;
            if (capMode){
              while(true){
                const res = await fetch('/api/local_map', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ character_id: savedCharacter, current_sector: centerId, max_hops: i }) });
                if (!res.ok) throw new Error('HTTP '+res.status);
                const data = await res.json();
                const n = (data.node_list||[]).length;
                if (n>maxNodes || n=== (lastData? lastData.node_list.length: -1)) { finalData = lastData || data; break; }
                lastData = data; i++; if (i>12) { finalData = data; break; }
              }
              hopsEl.value = String(i>0? i-1: 0);
            } else {
              const res = await fetch('/api/local_map', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ character_id: savedCharacter, current_sector: centerId, max_hops: hops }) });
              if (!res.ok) throw new Error('HTTP '+res.status);
              finalData = await res.json();
            }
            document.getElementById('json').value = JSON.stringify(finalData, null, 2);
            lastNodes = finalData.node_list || []; lastCenter = centerId; await render(lastNodes, lastCenter);
            if (!skipHistory){ history.splice(histIndex+1); history.push(centerId); histIndex = history.length-1; }
          }
        }catch(e){ alert('Fetch failed. If opening from file:// you may hit CORS or world-data/* not served.\n\nError: '+ e.message); }
      }
      document.getElementById('fetchBtn').addEventListener('click', fetchAndRender);
      // Log positions for debug IDs
      document.getElementById('logPosBtn').addEventListener('click', ()=>{
        if (!lastNodes || lastNodes.length===0) return;
        const idsStr = document.getElementById('debugIds').value || '';
        const ids = idsStr.split(/[,\s]+/).map(s=>parseInt(s,10)).filter(n=>!isNaN(n));
        const svg = document.getElementById('map');
        console.group('Node positions');
        for (const id of ids){
          const n = lastNodes.find(n=>n.id===id);
          if (!n){ console.log(id, 'not in current subgraph'); continue; }
          // Recompute layout positions quickly by asking the last render’s viewport transform
          // We can just read positions from the last render by querying circles
          const circle = Array.from(document.querySelectorAll('#nodes circle')).find(c=>{
            const x=c.nextSibling && c.nextSibling.textContent; return x && parseInt(x,10)===id;
          });
          if (circle){ console.log(id, { x: parseFloat(circle.getAttribute('cx')), y: parseFloat(circle.getAttribute('cy')) }); }
        }
        console.groupEnd();
      });

      // History navigation
      document.getElementById('prevBtn').addEventListener('click', async ()=>{
        if (histIndex > 0){ histIndex--; const c = history[histIndex]; centerEl.value = String(c); await fetchAndRender(true); }
      });
      document.getElementById('nextBtn').addEventListener('click', async ()=>{
        if (histIndex+1 < history.length){ histIndex++; const c = history[histIndex]; centerEl.value = String(c); await fetchAndRender(true); }
      });
      document.getElementById('randomBtn').addEventListener('click', async ()=>{
        if (!lastNodes || lastNodes.length===0){ await fetchAndRender(); return; }
        const idx = Math.floor(Math.random()*lastNodes.length); const c = lastNodes[idx].id; centerEl.value = String(c); await fetchAndRender();
      });

      // Seed with a tiny sample so the page shows something immediately
      const sample = { node_list: [
        { id: 39, visited: true, port_type: null, adjacent: [776, 286, 190] },
        { id: 776, visited: true, port_type: null, adjacent: [39, 578] },
        { id: 286, visited: false, port_type: 'SSS', adjacent: [39] },
        { id: 190, visited: true, port_type: 'STD', adjacent: [39, 199, 274] },
        { id: 199, visited: true, port_type: 'SBB', adjacent: [190, 274] },
        { id: 274, visited: false, port_type: 'SSS', adjacent: [190, 199, 174] },
        { id: 174, visited: false, port_type: null, adjacent: [274, 66] },
        { id: 66, visited: false, port_type: null, adjacent: [174, 177] },
        { id: 177, visited: false, port_type: null, adjacent: [66] }
      ]};
      document.getElementById('json').value = JSON.stringify(sample, null, 2);
      // Initial render
      (async () => { await render(sample.node_list, 39); })();
    </script>
  </body>
  </html>
