Answering Open Questions

1. **Event Ordering:** Should we guarantee order of events within a single operation? (Recommendation: Yes, using await on each emit)

Yes to recommendation.

2. **Event Acknowledgment:** Should clients acknowledge events? (Recommendation: No, keep it simple)

Agree. No ack.

3. **Event Replay:** Should clients be able to request missed events after reconnection? (Recommendation: Not in initial implementation, but design for future addition)

No replay.

4. **Rate Limiting:** Should events count towards rate limits? (Recommendation: No, only RPC requests)

No event rate limit. We only rate limit RPC requests.

5. **Batching:** Should multiple events from one operation be batched? (Recommendation: No, send individually for simplicity)

No. Send individually for simplicity.


----

- verbose_prompts in new task agent?
  - it doesn't look like the _setup_pipeline verbose logic is actually working, trace through
  - actually I think we can get rid of verbose_prompts because we have Pipecat log levels. 
- tool_call_event_callback and tool_result_event_callback? Needed?
- need to override tool executor or not?
- need self.messages?
- how do we implement max_iterations?
- format initial_state as summary

1. check finished logic
2. check canceled logic
3. check active task logic
4. check watchdog logic
5. check step counter logic
6. Events refactor
  - never send returned tool call data into context
  - send new events with payload and summary
    - task started
    - task finished
    - task step
    - task canceled
    

--

Can we better type these tool calls types?

PipelineToolExecutor = Callable[
    [Dict[str, Any]], Awaitable[Tuple[Optional[Dict[str, Any]], bool, Any]]
]
ToolEventCallback = Callable[[str, Any], Awaitable[None]]




---




We want to rename the commodities in the game.

Let's rename them to:
  - Fuel Ore (FO) -> Quantum Foam (QF)
  - Organics (OG) -> Retro-organics (RO)
  - Equipment (EQ) -> Neuro-symbolics (NS)

We need to change all instances of these names in the codebase. Change the full strings ("fuel ore", "organics", and "equipment") everywhere they appear. Change the abbreviations (FO, OG, EQ) wherever you are sure that those strings in context are used to refer to the commodities.




    - movement.start
    - movement.complete
    - character.moved
    - combat.round_waiting
    - combat.round_resolved
    - combat.ended
    - trade.executed
    - port.update


---

Is there ...
Shield regeneration?

---

From codex


• A few ideas to keep the momentum:

  - The garrison and combat privacy tests still rely heavily on event presence rather than on the actual combat
    outcomes. Extending them to check participant deltas or credit/knowledge updates would make regressions easier
    to catch.
  - We’re still tolerating the cascading @pytest.mark.integration warnings. With the marker now registered in
    pyproject.toml, consider tagging the suites deliberately (or silencing/parametrising runs) so CI output stays
    clean.
  - tests/test_combat_trade_events_integration.py and tests/test_async_game_client.py currently expect the legacy
    payload shapes. If we plan to keep them, adjusting their assertions would help us reintroduce those suites later
    without churn.
  - The runtime of test_salvage_collection_triggers_sector_update is still dominated by auto-brace sleeps. Replacing
    the 16‑second wait with explicit brace submissions (similar to the salvage fix) would shave off nearly half a
    minute and reduce flake potential.

---

# for codex next

We have end-to-end tests for combat events. These require a server to run.

The server can be started with this command.

```
PORT=8002 uv run game-server/server.py > game-server-debug.log 2>&1 
```

Then all the tests can be run like this:

```
uv run pytest tests/test_combat_scenarios_comprehensive.py -v
```

The full tests take about 215 seconds to run, because they need to wait on combat turn resolutions.

Add a note to your agents.md file about how to run these tests.

Go step-by-step and run each test individually. Examine the logs for the test, and the combat test code. We want to make sure that we are testing real-world scenarios and that the tests operate as expected without any false passes, unexpected results, or skipped logic.

When you are finished, write your analysis out to a file on disk.




# suggestions

## ship

Just send ship_type as a string, not the full ship config. We'll be sending this a lot. Maybe better to have a lookup table of ship types for the static info.

## port

Can we do this for port?

```
        "port": {
          "code": "SSS",
          "last_seen_prices": {
            "equipment": 38,
            "fuel_ore": 24,
            "organics": 9
          },
          "last_seen_stock": {
            "equipment": 700,
            "fuel_ore": 700,
            "organics": 700
          },
          "observed_at": "2025-10-05T23:31:15.362890+00:00"
        },
```

## sector

We need
  - garrisons?
  - salvage?


## players

For the non-self Player type
  - No id -- Player IDs are a game secret. I was thinking we can use unique IDs as a secret login token for player-created NPCs. So you never see another player's ID.
  - No extra information about the ship. You never see cargo for another player, and you only see shields and fighters when you are in combat.

```
        "players": [
          {
            "created_at": "2025-10-05T23:31:11.952390+00:00",
            "name": "toll-f",
            "player_type": "human"
            "ship": {
              "ship_type": "kestrel_courier",
              "ship_name": "Rolling Thunder",
            }
          }
        ],
```

----



next:
  - status payload
  - map local
  - movement start
  - movement end


Natural language -> conversation bot -> task LLM -> game server


TUI
  - Rip out and replace MyMap
    - map_region(center_sector, max_hops, max_count)
    - map_path(start_sector, end_sector, max_hops)
    - known_ports(center_sector, max_hops, max_count)
  - Router/memory equivalent to voice LLM?


----

Tool calls
  - my_status
  - plot_course
  - map_region
  - map_path
  - known_ports
  - move
  - check_trade
  - trade
  - recharge_warp_power
  - transfer_warp_power
  - transfer_credits
  - send_message
  - place_fighters
  - collect_fighters
  - attack
  - round_action
  - finished
  

  

----


Next:

- Remove everything in tui/ 

- The combat_interactive_tui.py code needs to automatically detect when a sector is in combat mode and switch to combat mode. Currently it does not do this. I see websocket combat events arriving, but the UI gives me a fight/wait choice rather than presenting me with the combat choices for the round.
- Add a "quiet|combat" indicator to the status bar. Update this information each time we receive a combat event.
- Add "fighters: N shields: M" information to the status bar. Update this information each time we receive a combat event.
--- done ---

- Whenever we prompt for input in the tui, provide a single-character response option. Either the first letter of the action name, or a number if there are target or sector options. Accept either the single-character or the full action string, whenever possible. Examine the code for all places where we prompt for a response and update them to use this approach. For single-character input options derived from the action name, indicate this option to the user by enclosing the first letter in parentheses. For example: (a)ttack, (b)race, (f)lee.

- Examine flee code and explain the success/fail logic

- Add Placeoption when the sector is not yet in combat mode: 

- Make another version of this TUI that can automatically switch between Task mode and Combat mode. Call it simple_tui.py. Use the code structure from combat_interactive_tui.py as a starting point.
  - When we're in task mode, send the full text of the input prompt to TaskAgent. Look at how ncp/run_npc.py does this. Append the _output from the TaskAgent using _append_log(). Rename anything in the code that should have more generic names, now that we support more modes.
  - When we are in a sector with active combat, use the same state and UI logic we have now in combat_interactive_tui.py.

- Examine the logic for collecting salvage.

- Fighters and sector visibility
  - DM whenever a player moves into a sector where you have fighters
  - DM whenever a player attacks your fighters




- why is api_send_message in server.py rather than defined in ./api/?
  - same question for server_status

Sunday
- Add a ws callback to AsyncGameClient so we can get rid of LoggingAsyncGameClient in combat_interactive_tup.py
- Clean up finished({message}) in TASK OUTPUT
- Fix AsyncGameClient caching/
- Further look at all tool calls to better summarize the resulting data structures in text
- See why we broke move UI graphics
- test run_npc.py and status_subscription_demo.py
- commit all files
- remove legacy gg-action keys and legacy result semantics (?)s
- utilities to create and manage characters and ports
  - remove character mod args from rpc join
  - create new admin rpc commands grouping that includes port management, too
    - create an admin password that we store in plain text in the world data file
- add transfer_credits rpc
  

# For supabase
- we should have table lines for everything
  - combat rounds
  - messages
  - player moves
  - etc etc
- the goals are
  - cleanly implement the same logic we have in game-server in supabase edge functions
  - be able to analyze what happened in a game by looking at everything that happened across a time range, in the database tables

# Things to write about.

Trying to write as little code as possible to perform game functions on behalf of a player. Instead, everything should be done by the LLM. This means writing more code to summarize game state and coordinate actions between the conversation and task LLMs.

How to avoid sending lots of data to the conversation LLM. my_map() tool as an example.


== sunday ==

----

Explain this code in AsyncGameClient

    async def _send_command(self, frame: Dict[str, Any]) -> Dict[str, Any]:
        await self._ensure_ws()
        req_id = frame.setdefault("id", str(uuid.uuid4()))
        fut: asyncio.Future = asyncio.get_running_loop().create_future()
        self._pending[req_id] = fut
        await self._ws.send(json.dumps(frame))
        msg = await fut
        if not msg.get("ok"):
            err = msg.get("error", {})
            raise RPCError(
                frame.get("type", "command"),
                int(err.get("status", 500)),
                str(err.get("detail", "Unknown error")),
                err.get("code"),
            )
        return msg.get("result", {})

----

  The most serious findings are:
  - Toll payment race condition in server.py (HIGH severity) - could corrupt credits
  - Event ordering bug in manager.py (MEDIUM-HIGH) - breaks client assumptions
  - Multiple memory leaks that will cause OOM over time

The suggestions are great. We'll work through implementing them soon.

But first let's make sure we're on the same page about the overall design of the system.

1. All game state is stored canonically on the server, in-memory in the game-server/server.py running process.
2. AsyncGameClient is a client-side library for accessing that state over a websocket connection and for sending game commands to the server.
3. All new combat logic is implemented in the game-server/combat/ directory. AsyncGameClient has no combat logic. The client sends combat actions to the server, which processes them and emits combat events to the client.

Before we proceed, add a section to the end of file-by-file-0928.md that lists all of the new websocket messages that we have added to this branch. (New websocket messages that do not exist in the `main` branch.) For each new websocket message, provide a complete example of the message, with all fields populated.

Other notes:
- Several issues you've identified and suggested fixes for are race conditions. Are there a real problem given that the server itself is single-threaded Python code?
- In addition to persisting game state on disk, we should save all game actions in a log. Suggest a log format. We could use JSONL and a file on disk. Or a SQLite table. Eventually we are going to port the game server to use supabase as a backend, so think about an interim step that will be a good transition to the final supabase-based solution.
- Are there places in the game server code where we should be handling how we persist game state to disk differently? For example, I could imagine using the game actions log above as our persistent message store, as well, rather than keeping separate message history files. Each client could keep a pointer to the last JSONL line number read, and scan the file from that point forward to catch up on any missed messages.

----

  Recommended Priority:

  1. Sector-specific locks - High impact on multi-player scalability
  2. EventDispatcher simplification - Medium impact on reliability
  3. Other issues - Low priority, document and monitor

  