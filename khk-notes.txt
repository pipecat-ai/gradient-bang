We are creating a plan to replace our existing event system with Supabase realtime events:
  - planning doc: planning-files/NEXT-supabase-migration-plan.md
  - overall migration to Supabase: planning-files/supabase-migration-plan.md

Read the planning-files/NEXT-supabase-migration-plan.md. 

Ultrathink about this plan. Identify any issues we should address in two main areas:
1. Pay particular attention to fan out helper logic. Is this complete and airtight?
2. Does this plan allow us to maintain complete compatibility with the public API surface area of the legacy AsyncGameClient implementation that we are replacing with this new Supabase system?


----

Question: is our plan to have an events table per character? 
  - One big events table that records each emitted event and then
  - Helper functions that write the event to each character's events table?

----

Codex: planning-files/supabase-events-rls-plan.md

Claude: planning-files/rls-event-delivery-plan.md


Compare your plan with planning-files/rls-event-delivery-plan.md. Ultrathink about the differences, strengths, and weaknesses. Tell me what you think should be incorporated into your plan from this other plan.


For Claude:

Compare our planning-files/rls-event-delivery-plan.md to a previous planning-files/supabase-events-rls-plan.md doc. Ultrathink about the differences in the two docs, how an implementation based on each would be different, and strengths/weaknesses of the two approaches. Do not change any code, yet.

For Codex:

Compare our planning-files/supabase-events-rls-plan.md to a previous planning-files/rls-event-delivery-plan.md doc. Ultrathink about the differences in the two docs, how an implementation based on each would be different, and strengths/weaknesses of the two approaches. Do not change any code, yet.

----

- Rate limits in a database table? What about supabase rate limits?
- Look at SQL tables (1.3)
  - And "Complete Implementation Checklist" 
- Examine tests/ -- what tests can we use unchanged?  

----

khkramer@boule:~/src/gradient-bang$ uv run scripts/character_create.py "Joe Player" --credits 100000
âœ“ Character created successfully.
  Name: Joe Player
  Character ID: 297dee08-284c-4dd2-b46b-3504344a0df9

export JOE=`uv run scripts/character_lookup.py "Joe Player"`

uv run npc/run_npc.py $JOE "Where am I?"

khkramer@boule:~/src/gradient-bang$ uv run scripts/corporation_create.py $JOE "Joe's Crew"
âœ“ Corporation created successfully.
  Name: Joe's Crew
  Corp ID: 1d2e47c6-997c-46c7-b1e0-187b89b17812
  Invite Code: d93d937a
  Founder ID: 297dee08-284c-4dd2-b46b-3504344a0df9
  Member Count: 1


----

1. Add credits to a corp ship when you purchase it. This is optional but highly recommended when you purchase a corp ship.
2. FUNCTION wiring below
3. Add corporation to ship payload for corp-owned ships.
4. Add new ship types.

----

  - ADD - Ship Purchase (personal or corporation)
  - ADD - Corporation management (create, join, leave)
  - REMOVE - MyMap (defined but not imported)
  - INVESTIGATE - StartTask/StopTask (defined but not imported)

----

khkramer@boule:~/src/gradient-bang$ uv run scripts/corporation_create.py `uv run scripts/character_lookup.py "Joe Player"` "Joe House"
âœ“ Corporation created successfully.
  Name: Joe House
  Corp ID: 8667a616-151d-4b74-bab6-46a901dbbe78
  Invite Code: 19110101
  Founder ID: 6d2bb10f-9197-4083-9f18-9ec49510c770
  Member Count: 1

Remove tests/integration-old

- Threading through corp id. For example in corporation_join event payload.
- Test lookup only corp members are allowed to supply a corp filter


- maybe remove corporation.info and my.corporation rpc calls. or maybe these are just for server admin


----

- add new ship types

Autonomous Probe
  - role = "autonomous"
  - price = 1000
  - trade_in_value = 0
  - cargo_holds = 
  - fighters = 10
  - shields = 0
  - turns_per_warp = 1
  - warp_power_capacity = 500
  - equipment_slots = 0
  - built_in_features = []

Autonomous Light Hauler
  - role = "autonomous"
  - price = 5000
  - trade_in_value = 0
  - cargo_holds = 20
  - fighters = 10
  - shields = 0
  - turns_per_warp = 5
  - warp_power_capacity = 500
  - equipment_slots = 0
  - built_in_features = []

- Change the cost to buy warp power to 1 credit per warp unit
- Add buying fighters. Should work the same way buying warp power does.
  - Fighter cost: 50 credit per fighter

1. Test joining a corp and buying an autonomous Probe
2. Work on long-running NPC
3. Test NPC plus retrieving log information


----


TASK UPGRADES

â— Summary

  I've completed a comprehensive analysis of the proposed task event changes. Here are the key findings:

  ðŸ“Š Current System

  - task_output: RTVI frame streaming progress (6 message types)
  - task_complete: Single event with was_cancelled flag (conflates outcomes)
  - No planning phase: LLM jumps directly to execution
  - No task.started event: Client doesn't know when task begins

  ðŸŽ¯ Proposed Changes (All 4 Items)

  1. Rename: task_output â†’ task.output ðŸŸ¢ Low complexity
  - Align with event naming conventions (combat.ended, salvage.created)
  - Breaking change for client

  2. Add: task.started event ðŸŸ¡ Medium complexity
  - Signal task initiation with task_id, description, timestamp
  - Provides clear lifecycle boundaries

  3. Separate: task.complete vs task.cancelled ðŸŸ¡ Medium complexity
  - Distinct events for distinct outcomes
  - task.complete: Successful completion only
  - task.cancelled: With reason (user_requested, error, combat, timeout)
  - Requires task state tracking (ID, start time, step count)

  4. Add: Planning phase ðŸ”´ High complexity
  - New LLM prompt: "Create a plan before executing"
  - New tool: submit_plan(plan_steps: string[])
  - New event: task.plan with estimated steps
  - Fallback: timeout after 30s, proceed without plan
  - Adds 2-5s latency but provides visibility into LLM approach

  ðŸ“‹ Implementation Phases

  Phase 1-2 (3-5 hours): Renames + event separationPhase 3 (1-2 hours): Add task.startedPhase 4 (4-6 hours): Planning phaseTotal: 8-13
  hours

  â“ Key Questions for You

  1. Scope: Do you want all 4 changes, or should we do them incrementally (e.g., start with 1-3, defer planning to later)?
  2. Planning Format: Should plan steps be freeform text array, or should we enforce structure (e.g., {step_number, description,
  estimated_duration})?
  3. Planning Requirement: Should tasks REQUIRE a plan before execution, or just strongly encourage it (with fallback)?
  4. Timing: Should I start implementing now, or do you want to review/modify the approach first?
  5. Client Impact: Are you okay with breaking changes that require client-side updates, or should we maintain backward compatibility?

  What would you like to do next?

----

Next up:

- tasks
  - change task_output to task.output
  - add task.started
  - separate task.complete and a new task.cancelled
  - prompt the llm to plan first with an estimated number of steps and output that.

- add something about salvage to the core game prompt (bot sometimes forgets it can collect salvage)

- separate PR
  - move credits to ship self: credits_on_hand in player becomes ship::credits
    - escape pods must not be able to hold credits


----

0. After we merge gp-1025 we need to make sure the event-logger is threaded through all new emits.
1. test_trade_event_visibility
2. Do we have good tests for multi-character fan-out of events received when a character moves or a trade is executed? Not log query fanout tests. But events received in realtime by multiple characters in a sector.
3. When we add garrison tests, we should make sure a player receives broadcast events from their garrison fighters in a different sectors, and add tests for being able to query combat events that happened to a player's garrison fighters. We may need new remote combat event types for this.

----

Look at server returing 500 instead of 400 for insufficient cargo. See if there are other instances of this.

----

We just merged some changes from a worktree. Commit d58a45462a82.

We need to align the new code with existing code, write new tests for the new functionality, and fix one test we broke. Let's ultrathink together about how to do that. Look at the existing test code, the test fixtures that start the test server, and the instructions for writing tests in CLAUDE.md. Then look at the outline of a work plan below, and write a doc out to planning-files/ with a detailed plan, plus any suggestions or questions you have.

1. The new events we've added in commit d58a45462a82 may not have proper EventLogger argument threading. Examine other event emit calls in the game server code and see if this needs to be updated.

2. All rpc calls that reference another player should use player name, not character ID. Examine all AsyncGameClient tool calls, tool schema definitions, and game server rpc handlers to see if any need to be updated. The sender's character ID should be used, but any selection of another player should use player name. Examine transfer rpc calls, combat rpc calls, message sending rpc calls, and investigate whether any other rpc calls need to be updated to use ONLY player display name. Make a plan for updating all rpc calls as necessary, along with associated tests.

3. We broke a few tests. Examine these tests and determine the changes in the code that are the root cause of the failures. Examine all other test code to see if we need to update any other tests. Also examine simple_tui.py and the code in client/ to see if we need to update any other code.

FAILED tests/integration/test_async_game_client.py::test_transfer_warp_power - TypeError: AsyncGameClient.transfer_warp_power() got an unexpected keyword argument 'to_character_id'
FAILED tests/integration/test_game_server_api.py::test_transfer_warp_power_to_character - TypeError: AsyncGameClient.transfer_warp_power() got an unexpected keyword argument 'to_character_id'
FAILED tests/unit/test_combat_finalization.py::TestFinalizeCombat::test_defeated_character_creates_salvage - AssertionError: update_credits('winner1', 1500) call not found
FAILED tests/unit/test_trade.py::test_trade_emits_enhanced_event_for_buy - AttributeError: 'DummyKnowledgeManager' object has no attribute 'get_bank_credits'. Did you mean: 'get_credits'?
FAILED tests/unit/test_trade.py::test_trade_emits_enhanced_event_for_sell - AttributeError: 'DummyKnowledgeManager' object has no attribute 'get_bank_credits'. Did you mean: 'get_credits'?

New functionality to ensure we have tests for:

4. Bank deposit and withdrawal

    - Deposit credits in the bank, when in sector 0. Player payload in sector.update event should update.
    - Withdraw credits from the bank, when in sector 0. Player payload in sector.update event should update.
    - Deposit more credits than available in credits_on_hand. Should fail.
    - Withdraw more credits than available in credits_in_bank. Should fail.
    - Deposit credits in the bank, when not in sector 0. Should fail.
    - Withdraw credits from the bank, when not in sector 0. Should fail.

5. Credit transfer between players

    - All credit transfer tests should use player names, not character IDs.
    - Transfer credits between players in the same sector. Player payloads in sector.update events should update to reflect the change in both player's credits_on_hand.
    - Attempt to transfer more credits than available in credits_on_hand. Should fail.
    - Transfer credits between players in different sectors. Should fail.

6. Cargo dumped as salvage

    - Do cargo dumps in a sector other than 0, just to avoid cluttering sector 0. Reset sector state between each test.
    - Dump cargo as salvage. All players in the sector should see events. Player's own ship::cargo should update.
    - Player retrieve their own dumped cargo. All players in the sector should see events. Player's own ship::cargo should update.
    - Another player retrieve the cargo. All players in the sector should see events, etc.
    - Player dump cargo, another player move into the sector, should see available salvage and be able to retrieve it. All events should fire as expected.
    - Dump more cargo than available. Should fail.

7. The game server is returning HTTP 500 instead of 400 for insufficient cargo when we try to sell at a port. It seems like the server should return 400. This is a small thing, but worth fixing anywhere we return a 500 instead of 400 for an error that is the result of a client miscalculation. Look at all of the rpc call handlers in the game server code and make a list of any places where we should return 400 instead of 500. We can update these, and then update any relevant tests.

----

If a player has a fighter in a sector, all events that would be sent to participants in that sector should be sent to the player. (And logged to the jsonl file as well, of course.)

Let's ultrathink together about a plan to implement this, including adding any test coverage we need. We want to write a doc out to planning-files/ to describe and track our work.

1. Examine the game server code to determine the best way to add event emitters that take into account the garrison in a sector. I think this may be as easy as adding logic in one place, to the player or sector filter.
2. Examine our current test coverage and suggest an efficient way to add test coverage specifically to make sure that a player receives events from their garrison fighters in a different sector, and that those events are returned from a query of the event log.
3. Create a detailed work plan, including a todo list.
4. Include a section in the doc for questions and suggestions.
5. Pause for us to discuss.


----

todo:
  - fix issues lower down
  - implement port 0 port - warp purchase, ship trade-in and purchase, bank (this needs data structure support)
  - implement buying a warp generator and warp generator warp recharge
  - implement player credits transfer
  - implement dumping cargo as salvage
  - implement log search
    - use log mechanic to implement logging for events in a sector with a character's fighter
  - implement game rules "docs map" lookup
  - refactor bot to remove most tools from voice agent
    - task
    - log search
    - ui triggers
  - implement gemini audio in module
  - think about corporations
  - implement hyperspace module
  - implement something worth defending -- citadel that does (what?)
  


Combat
  - Make it impossible to leave a sector when combat is happening
    - there's timing bugs -- need to prevent moves that are part of a task
  - When you drop out of a task because of combat, should get a task cancelled

Start people off with level 1 warp generator module (players have a natural tick)

Player trading
  - transfer credits and commodities

Why would this be a rate limit?
> ERROR:gradient-bang.rate_limit:Error processing request for TraderP: 400: Sector 0 is not adjacent to current sector 0 
- possibly related to previous errors in warp power failed buys

----

Work on npc/run_long_npc.py

0. System instructions
  - You are a non-player character in the space trading game. Etc.
  - Here is your personality and initial instructions.
0.5. google genai setup
  - use client.chats.create / client.chats.send_message

1. Create game client
2. Create experimental task agent
  - output callback that buffers lines
3. While true loop
  - send "Perform your next action" to the model
  - reponse should be "started task ..."
  - buffer output from the task
  - when task is complete, put the result in the chat as the next message


----

utils/experimental_pipecat_agent.py is an event-driven agent loop.

The core class is ExperimentalTaskAgent. We test it with npc/run_experimental_task.py script.

We want to replace the TaskAgent used in the Pipecat VoiceTaskManager with this new class. To that end, we should plan to do the following:

1. Evaluate any API differences between the TaskAgent and ExperimentalTaskAgent classes.
2. Formulate a plan to update either the ExperimentalTaskAgent class or the VoiceTaskManager to match the other.
3. Rename the ExperimentalTaskAgent class to TaskAgent and replace task_agent.py with a copy of experimental_pipecat_agent.py.
4. Leave the existing experiment_pipecat_agent.py in place for reference and further experimentation.

Do not change any code yet. Some API differences we will want to address is specific ways. For example, we will not want to implement a tool result callback.

Write a detailed planning document, describing API differences we will need to address, suggestions, and questions. Save that document to disk so that I can review it.



Explain all watchdog timers in the code. We may want to simplify the code to rely solely on the Pipecat pipeline idle timeout for top-level task "watchdog" time outs. If so, suggest how to make this property configurable in the ExperimentalTaskAgent constructor.

Note that you can develop and test end to end by running this, or a similar, command:

```
uv run npc/run_experimental_task.py codex-1 "Move to an adjacent sector, then do it again."
```

Always use uv. Redirect output to log files for analysis. Run the code you produce and analyze the output to ensure it is correct.


---


- restart context and work through all timers: agent watchdog, inference watchdog, and pipeline timeout
- logging cleanup:
  - add logging of Gemini chunks
  - remove all the complex logging
- test with standard pipecat checkout

----

â€¢ What Changed

  - Instrumented utils/experimental_pipecat_agent.py so error events can be trapped during a run: when
    STOP_ON_ERROR_EVENT=1 is set we log the offending payload to logs/error_events.jsonl, cancel the active pipeline,
    and raise immediately.
  - Hooked GoogleLLMService._stream_content (in the venv) to pickle the exact generate_content_stream argumentsâ€”
    raw contents, the constructed GenerateContentConfig, the derived generation_params, and tool schemaâ€”into logs/
    google_llm_service_request.pkl on every call.
  - Reworked scripts/replay_gemini_invocation.py to mirror Pipecatâ€™s requests precisely: it now shares a
    helper for dumping the replay payload in the same shape, supports --pickle [path] (defaulting to logs/
    google_llm_service_request.pkl), reconstructs Content objects and configs verbatim, and exposes the tool schema/
    tool_config we feed Gemini. It also prints function calls even when Gemini omits content.parts.
  - Added scripts/replay_gemini_service.py to route a captured invocation back through
    GoogleLLMService._stream_content, producing the same stream output without the rest of the pipeline.

  How to Reproduce the Bug Now

  1. cd /home/khkramer/src/gradient-bang
  2. . .env && export GOOGLE_API_KEY="$GOOGLE_API_KEY"
  3. export STOP_ON_ERROR_EVENT=1
  4. uv run npc/run_experimental_task.py khk-1 "Let's pair trade NS between 1477 and 675. Make round trips. Stop when
     you encounter an error."
      - When the first bad move happens youâ€™ll see it logged in logs/error_events.jsonl.
      - The most recent Gemini call is preserved in logs/google_llm_service_request.pkl.
  5. Reproduce the exact LLM decision off-line:
     uv run scripts/replay_gemini_invocation.py --pickle --show-metadata
     (or point at a copied pickle with --pickle logs/google_llm_service_request_latest.pkl).
     This issues the same generate_content_stream call that the agent made, letting you diff the streamed chunks
     against the live run.

  Notes

  - The pickle includes a JSON snapshot for ease of diffing, but the replay uses the original Content objects/config
    to eliminate any serialization drift.
  - scripts/replay_gemini_service.py full-run.json still works when you want to go through Pipecatâ€™s adapter/pipeline
    instead of the raw client.
  - .venv/lib/python3.12/site-packages/pipecat/services/google/llm.py now writes to logs/
    google_llm_service_request.pkl; undo or guard that instrumentation when youâ€™re done.

  Let me know if you want to automate diffing the pickled payloads or capture every call instead of just the latest


  ----


Testing function call accuracy:
  - full-run.json has a message sequence that failed in our pipecat pipeline with a duplicate move to 768.
  - but `uv run scripts/replay_gemini_invocation.py full-run.json` does the right thing, moving to 675

Why is the pipecat pipeline not doing the right thing?


---

Change summary lines
  - trade.executed: Trade executed for <character name>. -> Trade executed.
  - movement.complete: Moved to sector 1234. -> Now in sector 1234.

Create unique tool call IDs and add them to the event payload sent to the player who made the rpc call, and to the xml of the event summaries.

Example:
  <event name="movement.complete" tool_call_id="1234567890">...</event>


----

Remove fighters field from trade.executed event. Maybe change to Current cargo?

Event 1: <event name=trade.executed>\nTrade executed for John 34. Credits: 2770. Sold 30 quantum foam (@ 31 each, total 930). Cargo: 0 QF | 0 RO | 0 NS. Fighters: 300.\n</event>'




----

- verbose_prompts in new task agent?
  - it doesn't look like the _setup_pipeline verbose logic is actually working, trace through
  - actually I think we can get rid of verbose_prompts because we have Pipecat log levels. 
- tool_call_event_callback and tool_result_event_callback? Needed?
- need to override tool executor or not?
- need self.messages?
- how do we implement max_iterations?
- format initial_state as summary

1. check finished logic
2. check canceled logic
3. check active task logic
4. check watchdog logic
5. check step counter logic
6. Events refactor
  - never send returned tool call data into context
  - send new events with payload and summary
    - task started
    - task finished
    - task step
    - task canceled
    

--

Can we better type these tool calls types?

PipelineToolExecutor = Callable[
    [Dict[str, Any]], Awaitable[Tuple[Optional[Dict[str, Any]], bool, Any]]
]
ToolEventCallback = Callable[[str, Any], Awaitable[None]]




---




We want to rename the commodities in the game.

Let's rename them to:
  - Fuel Ore (FO) -> Quantum Foam (QF)
  - Organics (OG) -> Retro-organics (RO)
  - Equipment (EQ) -> Neuro-symbolics (NS)

We need to change all instances of these names in the codebase. Change the full strings ("fuel ore", "organics", and "equipment") everywhere they appear. Change the abbreviations (FO, OG, EQ) wherever you are sure that those strings in context are used to refer to the commodities.




    - movement.start
    - movement.complete
    - character.moved
    - combat.round_waiting
    - combat.round_resolved
    - combat.ended
    - trade.executed
    - port.update


---

Is there ...
Shield regeneration?

---

From codex


â€¢ A few ideas to keep the momentum:

  - The garrison and combat privacy tests still rely heavily on event presence rather than on the actual combat
    outcomes. Extending them to check participant deltas or credit/knowledge updates would make regressions easier
    to catch.
  - Weâ€™re still tolerating the cascading @pytest.mark.integration warnings. With the marker now registered in
    pyproject.toml, consider tagging the suites deliberately (or silencing/parametrising runs) so CI output stays
    clean.
  - tests/test_combat_trade_events_integration.py and tests/test_async_game_client.py currently expect the legacy
    payload shapes. If we plan to keep them, adjusting their assertions would help us reintroduce those suites later
    without churn.
  - The runtime of test_salvage_collection_triggers_sector_update is still dominated by auto-brace sleeps. Replacing
    the 16â€‘second wait with explicit brace submissions (similar to the salvage fix) would shave off nearly half a
    minute and reduce flake potential.

---

# for codex next

We have end-to-end tests for combat events. These require a server to run.

The server can be started with this command.

```
PORT=8002 uv run game-server/server.py > game-server-debug.log 2>&1 
```

Then all the tests can be run like this:

```
uv run pytest tests/test_combat_scenarios_comprehensive.py -v
```

The full tests take about 215 seconds to run, because they need to wait on combat turn resolutions.

Add a note to your agents.md file about how to run these tests.

Go step-by-step and run each test individually. Examine the logs for the test, and the combat test code. We want to make sure that we are testing real-world scenarios and that the tests operate as expected without any false passes, unexpected results, or skipped logic.

When you are finished, write your analysis out to a file on disk.




# suggestions

## ship

Just send ship_type as a string, not the full ship config. We'll be sending this a lot. Maybe better to have a lookup table of ship types for the static info.

## port

Can we do this for port?

```
        "port": {
          "code": "SSS",
          "last_seen_prices": {
            "equipment": 38,
            "fuel_ore": 24,
            "organics": 9
          },
          "last_seen_stock": {
            "equipment": 700,
            "fuel_ore": 700,
            "organics": 700
          },
          "observed_at": "2025-10-05T23:31:15.362890+00:00"
        },
```

## sector

We need
  - garrisons?
  - salvage?


## players

For the non-self Player type
  - No id -- Player IDs are a game secret. I was thinking we can use unique IDs as a secret login token for player-created NPCs. So you never see another player's ID.
  - No extra information about the ship. You never see cargo for another player, and you only see shields and fighters when you are in combat.

```
        "players": [
          {
            "created_at": "2025-10-05T23:31:11.952390+00:00",
            "name": "toll-f",
            "player_type": "human"
            "ship": {
              "ship_type": "kestrel_courier",
              "ship_name": "Rolling Thunder",
            }
          }
        ],
```

----



next:
  - status payload
  - map local
  - movement start
  - movement end


Natural language -> conversation bot -> task LLM -> game server


TUI
  - Rip out and replace MyMap
    - map_region(center_sector, max_hops, max_count)
    - map_path(start_sector, end_sector, max_hops)
    - known_ports(center_sector, max_hops, max_count)
  - Router/memory equivalent to voice LLM?


----

Tool calls
  - my_status
  - plot_course
  - map_region
  - map_path
  - known_ports
  - move
  - check_trade
  - trade
  - recharge_warp_power
  - transfer_warp_power
  - transfer_credits
  - send_message
  - place_fighters
  - collect_fighters
  - attack
  - round_action
  - finished
  

  

----


Next:

- Remove everything in tui/ 

- The combat_interactive_tui.py code needs to automatically detect when a sector is in combat mode and switch to combat mode. Currently it does not do this. I see websocket combat events arriving, but the UI gives me a fight/wait choice rather than presenting me with the combat choices for the round.
- Add a "quiet|combat" indicator to the status bar. Update this information each time we receive a combat event.
- Add "fighters: N shields: M" information to the status bar. Update this information each time we receive a combat event.
--- done ---

- Whenever we prompt for input in the tui, provide a single-character response option. Either the first letter of the action name, or a number if there are target or sector options. Accept either the single-character or the full action string, whenever possible. Examine the code for all places where we prompt for a response and update them to use this approach. For single-character input options derived from the action name, indicate this option to the user by enclosing the first letter in parentheses. For example: (a)ttack, (b)race, (f)lee.

- Examine flee code and explain the success/fail logic

- Add Placeoption when the sector is not yet in combat mode: 

- Make another version of this TUI that can automatically switch between Task mode and Combat mode. Call it simple_tui.py. Use the code structure from combat_interactive_tui.py as a starting point.
  - When we're in task mode, send the full text of the input prompt to TaskAgent. Look at how ncp/run_npc.py does this. Append the _output from the TaskAgent using _append_log(). Rename anything in the code that should have more generic names, now that we support more modes.
  - When we are in a sector with active combat, use the same state and UI logic we have now in combat_interactive_tui.py.

- Examine the logic for collecting salvage.

- Fighters and sector visibility
  - DM whenever a player moves into a sector where you have fighters
  - DM whenever a player attacks your fighters




- why is api_send_message in server.py rather than defined in ./api/?
  - same question for server_status

Sunday
- Add a ws callback to AsyncGameClient so we can get rid of LoggingAsyncGameClient in combat_interactive_tup.py
- Clean up finished({message}) in TASK OUTPUT
- Fix AsyncGameClient caching/
- Further look at all tool calls to better summarize the resulting data structures in text
- See why we broke move UI graphics
- test run_npc.py and status_subscription_demo.py
- commit all files
- remove legacy gg-action keys and legacy result semantics (?)s
- utilities to create and manage characters and ports
  - remove character mod args from rpc join
  - create new admin rpc commands grouping that includes port management, too
    - create an admin password that we store in plain text in the world data file
- add transfer_credits rpc
  

# For supabase
- we should have table lines for everything
  - combat rounds
  - messages
  - player moves
  - etc etc
- the goals are
  - cleanly implement the same logic we have in game-server in supabase edge functions
  - be able to analyze what happened in a game by looking at everything that happened across a time range, in the database tables

# Things to write about.

Emergent behavior - when we added dumping cargo, bots started doing that to buy things at ports.

Trying to write as little code as possible to perform game functions on behalf of a player. Instead, everything should be done by the LLM. This means writing more code to summarize game state and coordinate actions between the conversation and task LLMs.

Example of not hard-coding things:
  - player A tries to collect salvage
  - player B beats them to it, but after "collect salvage" action is attempted by Player A
  - LLM just "knows" what happened based on the event sequence. You don't hard-code it in the game logic that the game needs to "tell" the player that the other player beat them to it.

How to avoid sending lots of data to the conversation LLM. my_map() tool as an example.

It's a lot harder to get an LLM to handle event-driven metadata reliably than to handle information in tool responses reliably. OOD.


== sunday ==

----

Explain this code in AsyncGameClient

    async def _send_command(self, frame: Dict[str, Any]) -> Dict[str, Any]:
        await self._ensure_ws()
        req_id = frame.setdefault("id", str(uuid.uuid4()))
        fut: asyncio.Future = asyncio.get_running_loop().create_future()
        self._pending[req_id] = fut
        await self._ws.send(json.dumps(frame))
        msg = await fut
        if not msg.get("ok"):
            err = msg.get("error", {})
            raise RPCError(
                frame.get("type", "command"),
                int(err.get("status", 500)),
                str(err.get("detail", "Unknown error")),
                err.get("code"),
            )
        return msg.get("result", {})

----

  The most serious findings are:
  - Toll payment race condition in server.py (HIGH severity) - could corrupt credits
  - Event ordering bug in manager.py (MEDIUM-HIGH) - breaks client assumptions
  - Multiple memory leaks that will cause OOM over time

The suggestions are great. We'll work through implementing them soon.

But first let's make sure we're on the same page about the overall design of the system.

1. All game state is stored canonically on the server, in-memory in the game-server/server.py running process.
2. AsyncGameClient is a client-side library for accessing that state over a websocket connection and for sending game commands to the server.
3. All new combat logic is implemented in the game-server/combat/ directory. AsyncGameClient has no combat logic. The client sends combat actions to the server, which processes them and emits combat events to the client.

Before we proceed, add a section to the end of file-by-file-0928.md that lists all of the new websocket messages that we have added to this branch. (New websocket messages that do not exist in the `main` branch.) For each new websocket message, provide a complete example of the message, with all fields populated.

Other notes:
- Several issues you've identified and suggested fixes for are race conditions. Are there a real problem given that the server itself is single-threaded Python code?
- In addition to persisting game state on disk, we should save all game actions in a log. Suggest a log format. We could use JSONL and a file on disk. Or a SQLite table. Eventually we are going to port the game server to use supabase as a backend, so think about an interim step that will be a good transition to the final supabase-based solution.
- Are there places in the game server code where we should be handling how we persist game state to disk differently? For example, I could imagine using the game actions log above as our persistent message store, as well, rather than keeping separate message history files. Each client could keep a pointer to the last JSONL line number read, and scan the file from that point forward to catch up on any missed messages.

----

  Recommended Priority:

  1. Sector-specific locks - High impact on multi-player scalability
  2. EventDispatcher simplification - Medium impact on reliability
  3. Other issues - Low priority, document and monitor

  