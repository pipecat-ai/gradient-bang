<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Local Map (Cytoscape)</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b0b0b; color:#e5e7eb; }
      .wrap { max-width: 980px; margin: 18px auto; padding: 0 12px; }
      .row { display:flex; gap:12px; align-items:end; flex-wrap:wrap; }
      .card { background:#121212; border:1px solid #232323; border-radius:10px; padding:12px; min-width:0; }
      label { display:block; font-size:12px; opacity:.75; margin-bottom:4px; }
      input, textarea { background:#0f0f0f; color:#e5e7eb; border:1px solid #2a2a2a; border-radius:8px; padding:8px; width:100%; }
      textarea { height: 148px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
      button { background:#1f2937; color:#e5e7eb; border:1px solid #2b2b2b; border-radius:8px; padding:8px 12px; cursor:pointer; }
      button:hover { background:#263042; }
      svg { width:100%; height:560px; display:block; background: radial-gradient(1000px 400px at 50% 40%, #0f1012 0%, #0b0b0b 60%); border:1px solid #222; border-radius:12px; }
      .legend { display:flex; gap:10px; align-items:center; font-size:12px; opacity:.85; }
      .dot { width:12px; height:12px; border-radius:9999px; display:inline-block; border:1px solid #1f1f1f; }
      .dot.gray { background:#b0bec5; }
      .dot.red { background:#ef9a9a; }
      .dot.yellow { background:#ffd54f; }
      .muted { opacity:.7; }
      .small { font-size:12px; }
      .grid { display:grid; grid-template-columns: 1fr; gap:12px; overflow:hidden; }
      @media (min-width: 900px) { .grid { grid-template-columns: minmax(0, 1fr) 300px; } }
      #cy { box-sizing: border-box; }
    </style>
    <!-- Cytoscape core -->
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.30.4/dist/cytoscape.min.js"></script>
    <!-- Dependencies for fcose -->
    <script src="https://cdn.jsdelivr.net/npm/layout-base@2.0.1/layout-base.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cose-base@2.2.0/cose-base.min.js"></script>
    <!-- fcose layout -->
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-fcose@2.2.0/cytoscape-fcose.min.js"></script>
    <!-- Load our graph layout module -->
    <script src="graph_layout.js"></script>
  </head>
  <body>
    <div class="wrap">
      <h2 style="margin:6px 0 12px 0;">Local Map (Cytoscape)</h2>
      <div class="grid">
        <div class="card" style="overflow:hidden;">
          <div id="cy" style="width:100%; height:560px; background: radial-gradient(1000px 400px at 50% 40%, #0f1012 0%, #0b0b0b 60%); border:1px solid #222; border-radius:12px; overflow:hidden; position:relative;"></div>
          <div class="row" style="justify-content:space-between;margin-top:8px;">
            <div class="legend">
              <span class="dot yellow"></span> current
              <span class="dot gray" style="margin-left:10px"></span> visited
              <span class="dot red" style="margin-left:10px"></span> seen-only
              <span class="muted" style="margin-left:10px;">two-way has arrows at both ends</span>
            </div>
            <div class="small muted">Tip: Uncheck "Use world data" for API (needs game server) or paste JSON directly</div>
          </div>
        </div>
        <div style="display:flex; flex-direction:column; gap:12px;">
          <div class="card">
            <div class="row">
              <div style="flex:1;">
                <label>Center Sector</label>
                <input type="number" id="centerSector" placeholder="123" value="0" />
              </div>
              <div style="flex:1;">
                <label>Max Hops</label>
                <input type="number" id="maxHops" placeholder="5" value="3" />
              </div>
              <div style="flex:1; align-self:center; padding-top:16px;">
                <label style="display:flex; align-items:center; margin:0;">
                  <input type="checkbox" id="useWorld" checked style="width:auto; margin-right:6px;" />
                  <span>Use world data (global)</span>
                </label>
              </div>
            </div>
          </div>
          <button onclick="fetchLocalMap()">Fetch From API/World Data</button>
          <div class="row">
            <button onclick="prevSector()">◀ Prev</button>
            <button onclick="randomCenter()">Random Center</button>
            <button onclick="nextSector()">Next ▶</button>
          </div>
          <div class="row">
            <button onclick="rerunLayout()">Re-run Layout</button>
            <button onclick="runOptimize()">Optimize</button>
            <button onclick="fixRegions()">Fix Regions</button>
            <button onclick="fixCrossings()">Fix Crossings</button>
          </div>
          <div class="card">
            <label>Min node distance (px)</label>
            <input type="range" id="minNodeDist" min="2" max="40" value="4" oninput="document.getElementById('minNodeDistValue').textContent = this.value" />
            <span id="minNodeDistValue">4</span>
          </div>
          <div class="card">
            <label>Node repulsion</label>
            <input type="range" id="nodeRepulsion" min="500" max="32000" value="16000" oninput="document.getElementById('nodeRepulsionValue').textContent = this.value" />
            <span id="nodeRepulsionValue">16000</span>
          </div>
          <div class="card">
            <label style="display:flex; align-items:center; margin:0;">
              <input type="checkbox" id="limitNodes" checked style="width:auto; margin-right:6px;" />
              <span>Node render max</span>
              <input type="number" id="maxNodes" value="25" style="width:60px; margin-left:8px;" />
            </label>
          </div>
          <div class="card">
            <label style="display:flex; align-items:center; margin:0;">
              <input type="checkbox" id="skipOptRender" checked style="width:auto; margin-right:6px;" />
              <span>Skip render during optimization</span>
            </label>
            <span class="muted small">(auto-calc hops)</span>
          </div>
          <div class="card">
            <div>Nodes rendered: <strong id="nodeCount">0</strong></div>
          </div>
          <div class="card">
            <label>JSON Input (node_list or full response)</label>
            <textarea id="jsonInput" placeholder='{ "node_list": [ { "id": 123, "visited": true, "port_type": "SSS", "adjacent": [124, 200] }, ... ] }'></textarea>
            <div class="small muted" style="margin-top:6px;">Expected shape: { "node_list": [ { "id": 123, "visited": true, "port_type": "SSS", "adjacent": [124, 200] }, ... ] }</div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let cy = null;
      let currentNodes = [];
      let currentCenterId = null;

      // Update metrics display
      function updateMetrics(crossings, collisions) {
        console.log(`=== LAYOUT COMPLETE === Edge crossings: ${crossings}, Node collisions: ${collisions}`);
      }

      // Render the graph using the GraphLayout module
      async function renderGraph(nodes, centerId, quickMode = false) {
        currentNodes = nodes;
        currentCenterId = centerId;

        // Update node count
        document.getElementById('nodeCount').textContent = nodes.length;

        // Update JSON input
        document.getElementById('jsonInput').value = JSON.stringify({ node_list: nodes }, null, 2);

        // Destroy existing graph if any
        if (cy) {
          cy.destroy();
          cy = null;
        }

        // Get parameters
        const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 4;
        const nodeRepulsion = parseInt(document.getElementById('nodeRepulsion').value, 10) || 16000;
        const skipOptRender = document.getElementById('skipOptRender').checked;

        // Use the existing render method - it handles visualization
        cy = await GraphLayout.render(nodes, centerId, {
          container: document.getElementById('cy'),
          minNodeDist,
          nodeRepulsion,
          quickMode,
          autoOptimize: !quickMode,
          skipOptRender,
          onLayoutComplete: updateMetrics,
          onOptimizeProgress: (attempt, maxAttempts, crossings, collisions) => {
            console.log(`Optimization progress: ${attempt}/${maxAttempts} - ${crossings} crossings, ${collisions} collisions`);
          }
        });
      }

      // Fetch from API
      async function fetchLocalMap() {
        const center = document.getElementById('centerSector').value;
        let maxHops = document.getElementById('maxHops').value || 3;
        const limitNodes = document.getElementById('limitNodes').checked;
        const maxNodes = parseInt(document.getElementById('maxNodes').value, 10) || 25;
        const useWorld = document.getElementById('useWorld').checked;

        try {
          let nodes = [];

          if (limitNodes && useWorld) {
            // Adaptive fetching: start with 1 hop and increase until we have enough nodes
            for (let hops = 1; hops <= 10; hops++) {
              const url = `/local_map?center=${center}&max_hops=${hops}`;
              const response = await fetch(url);
              if (!response.ok) {
                console.error(`Failed to fetch world data for sector ${center}:`, response.status);
                break;
              }
              const data = await response.json();
              nodes = data.node_list || data.nodes || [];

              console.log(`Hops: ${hops}, Nodes: ${nodes.length}`);

              // If we have enough nodes, stop
              if (nodes.length >= maxNodes) {
                // If we have too many, use the previous hop count
                if (nodes.length > maxNodes && hops > 1) {
                  const prevUrl = `/local_map?center=${center}&max_hops=${hops - 1}`;
                  const prevResponse = await fetch(prevUrl);
                  if (prevResponse.ok) {
                    const prevData = await prevResponse.json();
                    nodes = prevData.node_list || prevData.nodes || [];
                    document.getElementById('maxHops').value = hops - 1;
                  }
                } else {
                  document.getElementById('maxHops').value = hops;
                }
                break;
              }

              // Update the hops display
              document.getElementById('maxHops').value = hops;
            }
          } else {
            // Standard fetching without node limit
            let response;
            let data;

            if (useWorld) {
              // Use world data - fetch from local map endpoint
              const url = `/local_map?center=${center}&max_hops=${maxHops}`;
              response = await fetch(url);
              if (!response.ok) {
                console.error(`Failed to fetch world data for sector ${center}:`, response.status);
                await renderGraph([], parseInt(center));
                return;
              }
              data = await response.json();
            } else {
              // Use API - POST to /api/my_map
              response = await fetch('/api/my_map', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  character_id: 'test_character'  // You may need to adjust this based on your character
                })
              });
              if (!response.ok) {
                console.error('API request failed:', response.status);
                await renderGraph([], parseInt(center));
                return;
              }
              data = await response.json();
            }

            nodes = data.node_list || data.nodes || [];
          }

          await renderGraph(nodes, parseInt(center));
        } catch (error) {
          console.error('Failed to fetch:', error);
          await renderGraph([], parseInt(center));
        }
      }

      // Random center
      async function randomCenter() {
        const center = Math.floor(Math.random() * 5000) + 1;
        document.getElementById('centerSector').value = center;
        await fetchLocalMap();
      }

      // Navigation
      async function prevSector() {
        const current = parseInt(document.getElementById('centerSector').value) || 0;
        document.getElementById('centerSector').value = Math.max(0, current - 1);
        await fetchLocalMap();
      }

      async function nextSector() {
        const current = parseInt(document.getElementById('centerSector').value) || 0;
        document.getElementById('centerSector').value = current + 1;
        await fetchLocalMap();
      }

      // Re-run layout
      async function rerunLayout() {
        if (currentNodes.length > 0) {
          // Always re-run with full optimization
          await renderGraph(currentNodes, currentCenterId, false);
        }
      }

      // Optimize
      async function runOptimize() {
        if (!cy) return;

        const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 4;
        const nodeRepulsion = parseInt(document.getElementById('nodeRepulsion').value, 10) || 16000;
        const skipOptRender = document.getElementById('skipOptRender').checked;

        // Use the existing optimize method that works with the visible graph
        const result = await GraphLayout.optimizeLayout(cy, {
          maxAttempts: 12,
          minNodeDist,
          nodeRepulsion,
          skipRender: skipOptRender,
          onProgress: (attempt, maxAttempts, crossings, collisions) => {
            console.log(`Optimization progress: ${attempt}/${maxAttempts} - ${crossings} crossings, ${collisions} collisions`);
          }
        });

        updateMetrics(result.crossings, result.collisions);
      }

      // Fix regions (stub for now)
      function fixRegions() {
        console.log('Fix regions not implemented in simplified version');
      }

      // Fix crossings
      async function fixCrossings() {
        if (!cy) return;

        // Run optimization specifically targeting crossings
        await runOptimize();
      }

      // Handle JSON input changes
      document.getElementById('jsonInput').addEventListener('input', async (e) => {
        try {
          const data = JSON.parse(e.target.value);
          const nodes = data.node_list || data.nodes || [];
          if (nodes.length > 0) {
            const centerId = nodes[0].id; // Use first node as center if not specified
            await renderGraph(nodes, centerId, false);
          }
        } catch (error) {
          // Invalid JSON, ignore
        }
      });

      // Initialize with default data
      window.addEventListener('DOMContentLoaded', async () => {
        // Check if there's initial data in the URL or fetch default
        const urlParams = new URLSearchParams(window.location.search);
        const center = urlParams.get('center');
        if (center) {
          document.getElementById('centerSector').value = center;
          await fetchLocalMap();
        } else {
          // Load default sector
          await fetchLocalMap();
        }
      });
    </script>
  </body>
</html>