<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Local Map (Cytoscape)</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b0b0b; color:#e5e7eb; }
      .wrap { max-width: 980px; margin: 18px auto; padding: 0 12px; }
      .row { display:flex; gap:12px; align-items:end; flex-wrap:wrap; }
      .card { background:#121212; border:1px solid #232323; border-radius:10px; padding:12px; min-width:0; }
      label { display:block; font-size:12px; opacity:.75; margin-bottom:4px; }
      input, textarea { background:#0f0f0f; color:#e5e7eb; border:1px solid #2a2a2a; border-radius:8px; padding:8px; width:100%; }
      textarea { height: 148px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
      button { background:#1f2937; color:#e5e7eb; border:1px solid #2b2b2b; border-radius:8px; padding:8px 12px; cursor:pointer; }
      button:hover { background:#263042; }
      svg { width:100%; height:560px; display:block; background: radial-gradient(1000px 400px at 50% 40%, #0f1012 0%, #0b0b0b 60%); border:1px solid #222; border-radius:12px; }
      .legend { display:flex; gap:10px; align-items:center; font-size:12px; opacity:.85; }
      .dot { width:12px; height:12px; border-radius:9999px; display:inline-block; border:1px solid #1f1f1f; }
      .dot.gray { background:#b0bec5; }
      .dot.red { background:#ef9a9a; }
      .dot.yellow { background:#ffd54f; }
      .muted { opacity:.7; }
      .small { font-size:12px; }
      .grid { display:grid; grid-template-columns: 1fr; gap:12px; overflow:hidden; }
      @media (min-width: 900px) { .grid { grid-template-columns: minmax(0, 1fr) 300px; } }
      #cy { box-sizing: border-box; }
    </style>
    <!-- Cytoscape core -->
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.30.4/dist/cytoscape.min.js"></script>
    <!-- Dependencies for cose-bilkent -->
    <script src="https://cdn.jsdelivr.net/npm/layout-base@2.0.1/layout-base.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cose-base@2.2.0/cose-base.min.js"></script>
    <!-- fcose layout -->
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-fcose@2.2.0/cytoscape-fcose.min.js"></script>
    <!-- cose-bilkent layout -->
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-cose-bilkent@4.1.0/cytoscape-cose-bilkent.min.js"></script>
  </head>
  <body>
    <div class="wrap">
      <h2 style="margin:6px 0 12px 0;">Local Map (Cytoscape)</h2>
      <div class="grid">
        <div class="card" style="overflow:hidden;">
          <div id="cy" style="width:100%; height:560px; background: radial-gradient(1000px 400px at 50% 40%, #0f1012 0%, #0b0b0b 60%); border:1px solid #222; border-radius:12px; overflow:hidden; position:relative;"></div>
          <div class="row" style="justify-content:space-between;margin-top:8px;">
            <div class="legend">
              <span class="dot yellow"></span> current
              <span class="dot gray" style="margin-left:10px"></span> visited
              <span class="dot red" style="margin-left:10px"></span> seen-only
              <span class="muted" style="margin-left:10px">two-way has arrows at both ends</span>
            </div>
            <div class="small muted">Tip: paste JSON or fetch from /api/local_map</div>
          </div>
        </div>
        <div class="card">
          <div class="row" style="align-items:flex-start;">
            <div style="flex:1 1 120px;">
              <label>Center Sector</label>
              <input id="center" type="number" value="0" />
            </div>
            <div style="flex:1 1 120px;">
              <label>Max Hops</label>
              <input id="hops" type="number" value="3" />
            </div>
            <div style="flex:1 1 180px; display:flex; gap:8px; align-items:center;">
              <input id="useWorld" type="checkbox" checked />
              <label for="useWorld" style="margin:0;">Use world data (global)</label>
            </div>
          </div>
          <div class="row" style="margin-top:8px;">
            <button id="fetchBtn">Fetch From /api/local_map</button>
          </div>
          <div class="row" style="margin-top:6px; align-items:center; gap:8px;">
            <button id="prevBtn">◀ Prev</button>
            <button id="randomBtn">Random Center</button>
            <button id="nextBtn">Next ▶</button>
          </div>
          <div class="row" style="margin-top:6px;">
            <button id="relayoutBtn">Re-run Layout</button>
            <button id="optimizeBtn" style="margin-left:8px;" title="Run multiple layouts and pick the one with fewest edge crossings and node/edge collisions">Optimize</button>
            <button id="fixRegionsBtn" style="margin-left:8px;" title="Fix nodes that should be inside regions">Fix Regions</button>
            <button id="fixCrossingsBtn" style="margin-left:8px;" title="Fix edge crossings for low-degree nodes">Fix Crossings</button>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <label class="small" style="margin:0;">Min node distance (px)</label>
            <input id="minNodeDist" type="range" min="2" max="20" step="1" value="6" style="width:160px;" />
            <span id="minNodeDistVal" class="small muted">6</span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <label class="small" style="margin:0;">Node repulsion</label>
            <input id="nodeRepulsion" type="range" min="1000" max="20000" step="500" value="16000" style="width:160px;" />
            <span id="nodeRepulsionVal" class="small muted">16000</span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <input id="capMode" type="checkbox" checked />
            <label for="capMode" class="small" style="margin:0;">Node render max</label>
            <input id="maxNodes" type="number" min="5" max="500" step="1" value="25" style="width:80px; margin-left:8px;" />
            <span class="small muted">(auto-calc hops)</span>
          </div>
          <div class="row" style="margin-top:6px; align-items:center;">
            <span class="small">Nodes rendered:&nbsp;<strong id="nodeCount">0</strong></span>
          </div>
          <div style="margin-top:10px;">
            <label>JSON Input (node_list or full response)</label>
            <textarea id="json"></textarea>
          </div>
          <div style="margin-top:8px;" class="small muted">
            Expected shape: { "node_list": [ { "id": 123, "visited": true, "port_type": "SSS", "adjacent": [124, 200] }, ... ] }
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global cytoscape instance
      let cy = null;
      
      // Global functions
      let fixSpecificCrossings = null;
      let applyCurvedEdges = null;
      let fixEnclosedRegions = null;
      let untangleKnots = null;
      
      // --- Graph helpers ---
      const TAU = Math.PI * 2;
      
      // Helper functions for graph analysis
      function buildUndirected(nodes) {
        const ids = new Set(nodes.map(n => n.id));
        const u = new Map();
        for (const n of nodes) {
          if (!u.has(n.id)) u.set(n.id, new Set());
          for (const t of n.adjacent || []) {
            if (!ids.has(t)) continue;
            if (!u.has(t)) u.set(t, new Set());
            u.get(n.id).add(t);
            u.get(t).add(n.id);
          }
        }
        return u;
      }

      function toPairs(nodes) {
        const idToNode = new Map(nodes.map(n => [n.id, n]));
        const map = new Map();
        for (const n of nodes) {
          for (const t of n.adjacent || []) {
            if (!idToNode.has(t)) continue;
            const a = Math.min(n.id, t), b = Math.max(n.id, t);
            const key = a + '-' + b;
            const rec = map.get(key) || { a, b, hasAB:false, hasBA:false };
            if (n.id === a) rec.hasAB = true; else rec.hasBA = true;
            map.set(key, rec);
          }
        }
        return Array.from(map.values());
      }

      // Function to count edge crossings
      function countCrossings(cyInstance) {
        let crossings = 0;
        const edges = cyInstance.edges();
        
        for (let i = 0; i < edges.length; i++) {
          for (let j = i + 1; j < edges.length; j++) {
            const e1 = edges[i];
            const e2 = edges[j];
            
            // Skip if edges share a node
            if (e1.source().id() === e2.source().id() || 
                e1.source().id() === e2.target().id() ||
                e1.target().id() === e2.source().id() ||
                e1.target().id() === e2.target().id()) {
              continue;
            }
            
            // Check if edges intersect
            const p1 = e1.source().position();
            const p2 = e1.target().position();
            const p3 = e2.source().position();
            const p4 = e2.target().position();
            
            // Line segment intersection test
            const ccw = (A, B, C) => {
              return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
            };
            
            if (ccw(p1, p3, p4) !== ccw(p2, p3, p4) && 
                ccw(p1, p2, p3) !== ccw(p1, p2, p4)) {
              crossings++;
            }
          }
        }
        
        return crossings;
      }
      
      // Function to count node/edge collisions
      function countNodeEdgeCollisions(cyInstance, verbose = false) {
        let collisions = 0;
        const collisionDetails = [];
        const minDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
        const nodeRadius = 20; // Node radius plus label space
        
        cyInstance.edges().forEach(edge => {
          const src = edge.source();
          const tgt = edge.target();
          const srcPos = src.position();
          const tgtPos = tgt.position();
          
          cyInstance.nodes().forEach(node => {
            if (node.id() !== src.id() && node.id() !== tgt.id()) {
              const nodePos = node.position();
              
              // Calculate distance from point to line segment
              const A = nodePos.x - srcPos.x;
              const B = nodePos.y - srcPos.y;
              const C = tgtPos.x - srcPos.x;
              const D = tgtPos.y - srcPos.y;
              
              const dot = A * C + B * D;
              const lenSq = C * C + D * D;
              
              if (lenSq === 0) return; // Edge has zero length
              
              let param = dot / lenSq;
              
              // Only consider the middle portion of the edge (not near endpoints)
              if (param > 0.1 && param < 0.9) {
                // Point on the edge closest to the node
                const xx = srcPos.x + param * C;
                const yy = srcPos.y + param * D;
                
                const dx = nodePos.x - xx;
                const dy = nodePos.y - yy;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // If edge passes through or very close to node
                if (distance < nodeRadius + minDist) {
                  collisions++;
                  if (verbose) {
                    collisionDetails.push({
                      node: node.id(),
                      edge: `${src.id()}-${tgt.id()}`,
                      distance: distance.toFixed(1)
                    });
                  }
                }
              }
            }
          });
        });
        
        if (verbose && collisionDetails.length > 0) {
          console.log(`Collision details (${collisionDetails.length} total):`);
          // Group by node
          const byNode = {};
          collisionDetails.forEach(detail => {
            if (!byNode[detail.node]) {
              byNode[detail.node] = [];
            }
            byNode[detail.node].push(detail.edge);
          });
          
          Object.entries(byNode).forEach(([node, edges]) => {
            console.log(`  Node ${node} collides with edges: ${edges.join(', ')}`);
          });
        }
        
        return collisions;
      }

      // --- Cytoscape Rendering ---
      async function render(nodes, centerId, quickMode = false) {
        console.log(`Render called with ${nodes.length} nodes, center: ${centerId}, quickMode: ${quickMode}`);
        
        // Prepare elements for Cytoscape
        const elements = [];
        
        // Add nodes
        for (const n of nodes) {
          const label = n.port_type ? `${n.id}\n${n.port_type}` : String(n.id);
          
          elements.push({
            data: { 
              id: String(n.id),
              label: label,
              visited: n.visited,
              port_type: n.port_type,
              isCenter: n.id === centerId
            },
            classes: n.id === centerId ? 'center' : (n.visited ? 'visited' : 'unvisited')
          });
        }
        
        // Add edges
        const pairs = toPairs(nodes);
        for (const e of pairs) {
          const edgeId = `${e.a}-${e.b}`;
          let targetArrow = 'none';
          let sourceArrow = 'none';
          
          if (e.hasAB && e.hasBA) {
            // Bidirectional
            targetArrow = 'triangle';
            sourceArrow = 'triangle';
          } else if (e.hasAB) {
            // A -> B
            targetArrow = 'triangle';
          } else if (e.hasBA) {
            // B -> A  
            sourceArrow = 'triangle';
          }
          
          elements.push({
            data: {
              id: edgeId,
              source: String(e.a),
              target: String(e.b),
              targetArrow: targetArrow,
              sourceArrow: sourceArrow
            }
          });
        }
        
        // Get layout parameters
        const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
        const nodeRepulsion = parseInt(document.getElementById('nodeRepulsion').value, 10) || 16000;
        
        // Configure layout options for high quality using fcose
        let layoutOptions = {
          name: 'fcose',
          animate: false,
          fit: true,
          padding: 30,
          randomize: true,
          quality: 'proof', // highest quality
          nodeDimensionsIncludeLabels: true,
          idealEdgeLength: edge => {
              // Shorter edges for adjacent nodes in the graph
              const src = edge.source();
              const tgt = edge.target();
              const srcDegree = src.degree();
              const tgtDegree = tgt.degree();
              const avgDegree = (srcDegree + tgtDegree) / 2;
              // Higher degree nodes get more space
            return Math.max(minNodeDist * 2, Math.min(minNodeDist * 8, 80 + avgDegree * 10));
          },
          nodeRepulsion: node => nodeRepulsion * 2.0, // Even stronger repulsion
          nodeOverlap: minNodeDist + 15, // Larger buffer for edges
          numIter: quickMode ? 5000 : 15000, // More iterations in quick mode for better quality
          tile: false,
          tilingPaddingVertical: 20,
          tilingPaddingHorizontal: 20,
          gravity: 0.05, // Even lower gravity
          gravityRange: 10.0, // Even wider gravity range
          initialEnergyOnIncremental: 0.05, // Very low initial energy
          edgeElasticity: edge => 0.2, // Lower elasticity for more flexible edges
          nestingFactor: 0.1,
          nodeSeparation: minNodeDist * 2,
          uniformNodeDimensions: false,
          packComponents: false, // No disconnected components
          step: 'all',
          // Additional parameters for edge crossing minimization
          sampleSize: 500, // Much larger sample size
          minTemp: 0.01, // Very low minimum temperature
          initialTemp: 500, // Higher initial temperature
          coolingFactor: 0.995, // Even slower cooling
          // Extra parameters
          componentSpacing: 150,
          nodeRepulsionUniformity: 0.3,
          // New parameters to reduce crossings
          improveFlow: true,
          randomizationSeed: Math.floor(Math.random() * 1000)
        };
        
        // Initialize or update Cytoscape
        if (cy) {
          cy.destroy();
        }
        
        cy = cytoscape({
          container: document.getElementById('cy'),
          elements: elements,
          autoungrabify: false,
          autounselectify: false,
          boxSelectionEnabled: false,
          minZoom: 0.5,
          maxZoom: 3,
          style: [
            {
              selector: 'node',
              style: {
                'label': 'data(label)',
                'text-valign': 'center',
                'text-halign': 'center',
                'font-size': '10px',
                'color': '#e0e0e0',
                'text-wrap': 'wrap',
                'text-max-width': '60px',
                'width': '30px',
                'height': '30px',
                'background-color': '#b0bec5',
                'border-color': '#1f1f1f',
                'border-width': 1
              }
            },
            {
              selector: 'node.center',
              style: {
                'background-color': '#ffd700',
                'color': '#000000'  // Black text for better readability on gold background
              }
            },
            {
              selector: 'node.visited',
              style: {
                'background-color': '#b0bec5',
                'color': '#000000'  // Black text for better readability
              }
            },
            {
              selector: 'node.unvisited',
              style: {
                'background-color': '#ef9a9a'
              }
            },
            {
              selector: 'edge',
              style: {
                'width': 1.25,
                'opacity': 0.85,
                'line-color': '#9aa0a6',
                'target-arrow-shape': 'data(targetArrow)',
                'source-arrow-shape': 'data(sourceArrow)',
                'target-arrow-color': '#9aa0a6',
                'source-arrow-color': '#9aa0a6',
                'arrow-scale': 1.2,  // Make arrows slightly larger
                'curve-style': 'straight'
              }
            }
          ]
        });
        
        // After initial layout, check if optimization is needed
        const currentNodes = nodes;  // Capture nodes in closure
        const currentCenterId = centerId;  // Capture centerId in closure
        
        console.log('Setting up layoutstop event handler for auto-optimization...');
        
        // Store the optimization function to ensure proper async handling
        const runAutoOptimization = async () => {
          console.log(`Layout stopped. quickMode: ${quickMode}`);
          // Only auto-optimize if this isn't from an optimize call (quickMode)
          if (!quickMode) {
            const crossings = countCrossings(cy);
            const collisions = countNodeEdgeCollisions(cy);
            console.log(`Initial layout complete: ${crossings} edge crossings, ${collisions} node/edge collisions`);
            
            // If there are problems, auto-run optimization
            if (crossings > 0 || collisions > 0) {
              console.log('Auto-running optimization due to crossings/collisions...');
              
              // Run optimization - start with current layout as best
              let bestPositions = {};
              cy.nodes().forEach(node => {
                bestPositions[node.id()] = node.position();
              });
              let bestScore = crossings + collisions;
              let bestCrossings = crossings;
              let bestCollisions = collisions;
              
              // Try up to 12 different random layouts, but stop early if perfect
              let maxAttempts = 12;
              let actualAttempts = 0;
              
              for (let attempt = 0; attempt < maxAttempts; attempt++) {
                actualAttempts++;
                console.log(`Starting optimization attempt ${attempt + 1} of ${maxAttempts}...`);
                
                // Add small delay between attempts to clear any internal state
                if (attempt > 0) {
                  await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                // Re-run layout with new random seed (don't recreate entire Cytoscape)
                const optLayoutOptions = {
                  name: 'fcose',
                  quality: attempt % 3 === 0 ? 'proof' : 'default', // Mix quality settings for variety
                  randomize: true,
                  animate: false,
                  fit: false,  // Don't fit during optimization attempts
                  nodeDimensionsIncludeLabels: true,
                  idealEdgeLength: edge => {
                    const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
                    const src = edge.source();
                    const tgt = edge.target();
                    const srcDegree = src.degree();
                    const tgtDegree = tgt.degree();
                    const avgDegree = (srcDegree + tgtDegree) / 2;
                    return Math.max(minNodeDist * 2, Math.min(minNodeDist * 8, 80 + avgDegree * 10));
                  },
                  nodeRepulsion: node => {
                    const nodeRepulsion = parseInt(document.getElementById('nodeRepulsion').value, 10) || 16000;
                    return nodeRepulsion * 2.0;
                  },
                  nodeOverlap: parseInt(document.getElementById('minNodeDist').value, 10) + 15,
                  numIter: 5000,  // Quick iterations for optimization
                  randomizationSeed: Math.floor(Math.random() * 1000)
                };
                
                // Wait for layout to complete
                await new Promise(resolve => {
                  console.log('  Creating layout...');
                  const layout = cy.layout(optLayoutOptions);
                  
                  let resolved = false;
                  
                  // Set up timeout in case event doesn't fire
                  const timeout = setTimeout(() => {
                    if (!resolved) {
                      console.log('  Layout timeout - proceeding anyway');
                      resolved = true;
                      resolve();
                    }
                  }, 3000);
                  
                  // Listen for layout completion BEFORE running
                  cy.one('layoutstop', () => {
                    if (!resolved) {
                      console.log('  Layout complete event received');
                      clearTimeout(timeout);
                      resolved = true;
                      setTimeout(resolve, 100);  // Small delay for positions to stabilize
                    }
                  });
                  
                  // Actually run the layout
                  console.log('  Starting layout.run()...');
                  try {
                    layout.run();
                    console.log('  layout.run() called successfully');
                  } catch (err) {
                    console.error('  Error running layout:', err);
                    clearTimeout(timeout);
                    resolved = true;
                    resolve();
                  }
                });
                
                if (cy) {
                  const currentCrossings = countCrossings(cy);
                  const currentCollisions = countNodeEdgeCollisions(cy);
                  const totalScore = currentCrossings + currentCollisions;
                  console.log(`  Attempt ${attempt + 1}: ${currentCrossings} crossings, ${currentCollisions} collisions`);
                  
                  if (totalScore < bestScore) {
                    bestScore = totalScore;
                    bestCrossings = currentCrossings;
                    bestCollisions = currentCollisions;
                    bestPositions = {};
                    cy.nodes().forEach(node => {
                      bestPositions[node.id()] = node.position();
                    });
                  }
                  
                  // If we found a perfect layout, stop early
                  if (bestScore === 0) {
                    console.log(`Perfect layout found after ${actualAttempts} attempts!`);
                    break;
                  }
                  
                  // If we're close (just 1 crossing/collision) and haven't tried many extra attempts, keep trying
                  if (bestScore === 1 && attempt === maxAttempts - 1 && maxAttempts < 20) {
                    console.log(`Close to perfect (score=1), trying ${4} more attempts...`);
                    maxAttempts += 4;
                  }
                } else {
                  console.log('Warning: cy is undefined after layout attempt');
                }
              }
              
              console.log(`Auto-optimization finished after ${actualAttempts} attempts with score ${bestScore}`)
              
              // Apply best layout (if positions changed during optimization)
              if (bestPositions && cy) {
                // Only apply positions if we didn't just find a perfect layout
                // (in which case the positions are already correct)
                if (bestScore !== 0 || actualAttempts > 1) {
                  cy.nodes().forEach(node => {
                    if (bestPositions[node.id()]) {
                      node.position(bestPositions[node.id()]);
                    }
                  });
                }
                
                console.log(`Optimization complete: ${bestCrossings} crossings, ${bestCollisions} collisions`);
              }
              
              // Always fit the graph to the view area after optimization
              if (cy) {
                cy.fit();
              }
              
              // If there are still crossings or collisions, try Fix Regions + Fix Crossings sequence
              if (cy && (bestCrossings > 0 || bestCollisions > 0) && fixEnclosedRegions) {
                  console.log('Running Fix Regions + Fix Crossings sequence...');
                  
                  // Save the initial positions before Fix Regions runs
                  const initialPositions = {};
                  cy.nodes().forEach(node => {
                    initialPositions[node.id()] = {...node.position()};
                  });
                  const initialCrossings = bestCrossings;
                  const initialCollisions = bestCollisions;
                  
                  // Run Fix Regions
                  fixEnclosedRegions();
                  
                  // Check metrics after Fix Regions
                  const afterRegionsCrossings = countCrossings(cy);
                  const afterRegionsCollisions = countNodeEdgeCollisions(cy, true);
                  console.log(`After Fix Regions: ${afterRegionsCrossings} crossings, ${afterRegionsCollisions} collisions`);
                  
                  // Detect if Fix Regions created a knot
                  const createdKnot = (afterRegionsCrossings > initialCrossings || afterRegionsCollisions > initialCollisions * 2);
                  
                  if (createdKnot) {
                    console.log(`Fix Regions created a knot (${initialCrossings}→${afterRegionsCrossings} crossings, ${initialCollisions}→${afterRegionsCollisions} collisions)`);
                    
                    // Restore initial positions
                    cy.nodes().forEach(node => {
                      if (initialPositions[node.id()]) {
                        node.position(initialPositions[node.id()]);
                      }
                    });
                    console.log('Restored initial positions due to knot creation');
                  } else {
                    // Fix Regions helped or was neutral, continue with rest of optimization
                    console.log('Fix Regions completed without creating knots');
                    
                    // Small layout adjustment - this can make unsolvable crossings solvable!
                    await new Promise(resolve => {
                      cy.layout({
                        name: 'fcose',
                        quality: 'default',
                        numIter: 300,
                        animate: false,
                        randomize: false,
                        idealEdgeLength: edge => {
                          const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
                          return Math.max(minNodeDist * 2, 80);
                        },
                        nodeRepulsion: 5000,
                        edgeElasticity: 0.45
                      }).run();
                      
                      cy.one('layoutstop', () => {
                        setTimeout(resolve, 200);
                      });
                    });
                    
                    // Run Fix Crossings
                    if (fixSpecificCrossings) {
                      fixSpecificCrossings();
                    }
                    
                    const finalCrossings = countCrossings(cy);
                    const finalCollisions = countNodeEdgeCollisions(cy);
                    console.log(`Final optimization result: ${finalCrossings} crossings, ${finalCollisions} collisions`);
                    
                    // Update best metrics
                    bestCrossings = finalCrossings;
                    bestCollisions = finalCollisions;
                  }
                  
                  // Fit to view after Fix Regions
                  cy.fit();
                }
            }
          }
        };
        
        // Register the event handler
        cy.one('layoutstop', runAutoOptimization);
        
        // Function to detect and fix enclosed regions
        fixEnclosedRegions = () => {
          if (!cy) return;
          
          console.log(`Fix Regions: Graph has ${cy.nodes().length} nodes and ${cy.edges().length} edges`);
          
          // Find cycles in the graph
          const findCycles = () => {
            const cycles = [];
            const nodes = cy.nodes();
            const cycleSet = new Set(); // To avoid duplicate cycles
            
            // For small graphs, find 4-cycles (boxes)
            // A 4-cycle is: n1 -> n2 -> n4 -> n3 -> n1
            nodes.forEach(n1 => {
              const n1Edges = n1.connectedEdges();
              const n1Neighbors = n1.neighborhood().nodes();
              
              n1Neighbors.forEach(n2 => {
                // Avoid checking same pair twice
                if (parseInt(n2.id()) <= parseInt(n1.id())) return;
                
                // Get n2's neighbors
                const n2Neighbors = n2.neighborhood().nodes();
                
                // Look for n3 that connects to n1 (but is not n2)
                n1Neighbors.forEach(n3 => {
                  if (n3.id() === n2.id()) return;
                  if (parseInt(n3.id()) <= parseInt(n1.id())) return;
                  
                  // Now look for n4 that connects both n2 and n3
                  const n3Neighbors = n3.neighborhood().nodes();
                  
                  // Find nodes connected to both n2 and n3
                  n2Neighbors.forEach(n4 => {
                    // Skip if n4 is n1, n2, or n3
                    if (n4.id() === n1.id() || n4.id() === n2.id() || n4.id() === n3.id()) return;
                    
                    // Check if n4 is also connected to n3
                    if (n3Neighbors.some(n => n.id() === n4.id())) {
                      // We have a 4-cycle: n1-n2-n4-n3-n1
                      // Make sure we haven't already found this cycle
                      const cycleIds = [n1.id(), n2.id(), n3.id(), n4.id()]
                        .map(id => parseInt(id))
                        .sort((a, b) => a - b)
                        .join('-');
                        
                      if (!cycleSet.has(cycleIds)) {
                        cycleSet.add(cycleIds);
                        cycles.push([n1, n2, n4, n3]); // Order matters for proper cycle
                        console.log(`Found 4-cycle: ${n1.id()} -> ${n2.id()} -> ${n4.id()} -> ${n3.id()} -> ${n1.id()}`);
                      }
                    }
                  });
                });
              });
            });
            
            console.log(`Total cycles found: ${cycles.length}`);
            
            // If no cycles found with strict method, try alternative approach
            if (cycles.length === 0) {
              console.log('No cycles found with strict method, trying alternative approach...');
              
              // Look for nodes that might be "inside" based on connection patterns
              nodes.forEach(centerNode => {
                const neighbors = centerNode.neighborhood().nodes();
                
                // If a node has 4+ neighbors that form connections between them, it might be a center
                if (neighbors.length >= 4) {
                  // Check if any 4 of the neighbors form a cycle
                  for (let i = 0; i < neighbors.length - 3; i++) {
                    for (let j = i + 1; j < neighbors.length - 2; j++) {
                      for (let k = j + 1; k < neighbors.length - 1; k++) {
                        for (let l = k + 1; l < neighbors.length; l++) {
                          const n1 = neighbors[i];
                          const n2 = neighbors[j];
                          const n3 = neighbors[k];
                          const n4 = neighbors[l];
                          
                          // Check if these 4 nodes form a cycle
                          const edges = cy.edges();
                          let edgeCount = 0;
                          
                          // Count edges between these 4 nodes
                          if (edges.some(e => 
                            (e.source().id() === n1.id() && e.target().id() === n2.id()) ||
                            (e.source().id() === n2.id() && e.target().id() === n1.id()))) edgeCount++;
                          if (edges.some(e => 
                            (e.source().id() === n2.id() && e.target().id() === n3.id()) ||
                            (e.source().id() === n3.id() && e.target().id() === n2.id()))) edgeCount++;
                          if (edges.some(e => 
                            (e.source().id() === n3.id() && e.target().id() === n4.id()) ||
                            (e.source().id() === n4.id() && e.target().id() === n3.id()))) edgeCount++;
                          if (edges.some(e => 
                            (e.source().id() === n4.id() && e.target().id() === n1.id()) ||
                            (e.source().id() === n1.id() && e.target().id() === n4.id()))) edgeCount++;
                          
                          // If we have 4 edges forming a cycle
                          if (edgeCount === 4) {
                            const cycleIds = [n1.id(), n2.id(), n3.id(), n4.id()]
                              .map(id => parseInt(id))
                              .sort((a, b) => a - b)
                              .join('-');
                              
                            if (!cycleSet.has(cycleIds)) {
                              cycleSet.add(cycleIds);
                              cycles.push([n1, n2, n3, n4]);
                              console.log(`Found 4-cycle (alternative): ${n1.id()}, ${n2.id()}, ${n3.id()}, ${n4.id()} around center ${centerNode.id()}`);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              });
              
              console.log(`Total cycles after alternative method: ${cycles.length}`);
            }
            
            return cycles;
          };
          
          // Determine if a node should be inside, outside, or unchanged relative to a cycle
          const getNodePlacement = (node, cycle) => {
            // Check if node is connected to cycle nodes
            let connections = 0;
            const connectedCycleNodes = [];
            cycle.forEach(cycleNode => {
              if (node.neighborhood().nodes().some(n => n.id() === cycleNode.id())) {
                connections++;
                connectedCycleNodes.push(cycleNode);
              }
            });
            
            // Count non-cycle connections
            const nonCycleConnections = node.neighborhood().nodes().filter(n => 
              !cycle.some(cn => cn.id() === n.id())
            ).length;
            
            // Get cycle center for position checking
            let centerX = 0, centerY = 0;
            cycle.forEach(n => {
              const pos = n.position();
              centerX += pos.x;
              centerY += pos.y;
            });
            centerX /= cycle.length;
            centerY /= cycle.length;
            
            // Check if node is currently inside the cycle (roughly)
            const nodePos = node.position();
            const distToCenter = Math.sqrt(
              Math.pow(nodePos.x - centerX, 2) + 
              Math.pow(nodePos.y - centerY, 2)
            );
            
            // Calculate average distance of cycle nodes from center
            let avgCycleDistance = 0;
            cycle.forEach(n => {
              const pos = n.position();
              avgCycleDistance += Math.sqrt(
                Math.pow(pos.x - centerX, 2) + 
                Math.pow(pos.y - centerY, 2)
              );
            });
            avgCycleDistance /= cycle.length;
            
            const isCurrentlyInside = distToCenter < avgCycleDistance * 0.8;
            
            // Decision logic
            if (connections >= 2 && nonCycleConnections <= 1) {
              // Strong case for being inside: connected to multiple cycle nodes, few external connections
              if (!isCurrentlyInside) {
                console.log(`Node ${node.id()} should move INSIDE: ${connections} cycle connections, ${nonCycleConnections} external`);
                return 'inside';
              }
            } else if (connections === 1 && nonCycleConnections >= 1) {
              // Should be outside: only one cycle connection and has external connections
              if (isCurrentlyInside) {
                console.log(`Node ${node.id()} should move OUTSIDE: only ${connections} cycle connection, ${nonCycleConnections} external`);
                return 'outside';
              }
            } else if (connections === 0) {
              // Not connected to cycle at all, should definitely be outside
              if (isCurrentlyInside) {
                console.log(`Node ${node.id()} should move OUTSIDE: no cycle connections`);
                return 'outside';
              }
            }
            
            return 'unchanged';
          };
          
          // Place node inside a cycle
          const placeInside = (node, cycle) => {
            // Calculate center of the cycle
            let centerX = 0, centerY = 0;
            cycle.forEach(n => {
              const pos = n.position();
              centerX += pos.x;
              centerY += pos.y;
            });
            centerX /= cycle.length;
            centerY /= cycle.length;
            
            // Move node more aggressively toward center
            const currentPos = node.position();
            const newX = centerX * 0.85 + currentPos.x * 0.15;  // Move 85% toward center
            const newY = centerY * 0.85 + currentPos.y * 0.15;
            
            console.log(`Moving node ${node.id()} INSIDE from (${currentPos.x.toFixed(0)}, ${currentPos.y.toFixed(0)}) to (${newX.toFixed(0)}, ${newY.toFixed(0)})`);
            node.position({ x: newX, y: newY });
          };
          
          // Place node outside a cycle
          const placeOutside = (node, cycle) => {
            // Calculate center of the cycle
            let centerX = 0, centerY = 0;
            cycle.forEach(n => {
              const pos = n.position();
              centerX += pos.x;
              centerY += pos.y;
            });
            centerX /= cycle.length;
            centerY /= cycle.length;
            
            // Find which cycle node this node is connected to
            let connectedCycleNode = null;
            cycle.forEach(cycleNode => {
              if (node.neighborhood().nodes().some(n => n.id() === cycleNode.id())) {
                connectedCycleNode = cycleNode;
              }
            });
            
            if (connectedCycleNode) {
              // Move node away from center, past the connected cycle node
              const cycleNodePos = connectedCycleNode.position();
              const dirX = cycleNodePos.x - centerX;
              const dirY = cycleNodePos.y - centerY;
              const dirLength = Math.sqrt(dirX * dirX + dirY * dirY);
              
              if (dirLength > 0) {
                // Normalize and extend beyond the cycle node
                const newX = cycleNodePos.x + (dirX / dirLength) * 100;
                const newY = cycleNodePos.y + (dirY / dirLength) * 100;
                
                console.log(`Moving node ${node.id()} OUTSIDE from (${node.position().x.toFixed(0)}, ${node.position().y.toFixed(0)}) to (${newX.toFixed(0)}, ${newY.toFixed(0)})`);
                node.position({ x: newX, y: newY });
              }
            } else {
              // No connection to cycle, just move away from center
              const currentPos = node.position();
              const dirX = currentPos.x - centerX;
              const dirY = currentPos.y - centerY;
              const dirLength = Math.sqrt(dirX * dirX + dirY * dirY);
              
              if (dirLength > 0) {
                const newX = centerX + (dirX / dirLength) * 200;
                const newY = centerY + (dirY / dirLength) * 200;
                
                console.log(`Moving node ${node.id()} OUTSIDE (no connection) from (${currentPos.x.toFixed(0)}, ${currentPos.y.toFixed(0)}) to (${newX.toFixed(0)}, ${newY.toFixed(0)})`);
                node.position({ x: newX, y: newY });
              }
            }
          };
          
          // Find cycles and fix enclosed nodes
          console.log('Fix Regions: Starting cycle detection...');
          const cycles = findCycles();
          
          let nodesMovedIn = 0;
          let nodesMovedOut = 0;
          
          cycles.forEach((cycle, idx) => {
            const cycleNodeIds = cycle.map(n => n.id()).join(', ');
            console.log(`Checking cycle ${idx + 1}: [${cycleNodeIds}]`);
            
            cy.nodes().forEach(node => {
              // Skip nodes that are part of the cycle
              if (cycle.some(n => n.id() === node.id())) return;
              
              const placement = getNodePlacement(node, cycle);
              
              if (placement === 'inside') {
                placeInside(node, cycle);
                nodesMovedIn++;
              } else if (placement === 'outside') {
                placeOutside(node, cycle);
                nodesMovedOut++;
              }
            });
          });
          
          // Report final metrics after Fix Regions
          const crossingsAfterFix = countCrossings(cy);
          const collisionsAfterFix = countNodeEdgeCollisions(cy, true); // Enable verbose mode to see collision details
          console.log(`Fix Regions complete: ${nodesMovedIn} nodes moved IN, ${nodesMovedOut} nodes moved OUT`);
          console.log(`  Metrics after Fix Regions: ${crossingsAfterFix} crossings, ${collisionsAfterFix} collisions`);
        };
        
        // Function to fix node/edge collisions
        fixNodeEdgeCollisions = () => {
          if (!cy) return;
          
          const nodeRadius = 20; // Node radius plus label space
          const minSeparation = 30; // Minimum distance between node center and edge
          let collisionsFixed = 0;
          
          cy.nodes().forEach(node => {
            const nodePos = node.position();
            let closestCollision = null;
            let closestDistance = Infinity;
            
            // Check this node against all edges
            cy.edges().forEach(edge => {
              const src = edge.source();
              const tgt = edge.target();
              
              // Skip edges connected to this node
              if (src.id() === node.id() || tgt.id() === node.id()) return;
              
              const srcPos = src.position();
              const tgtPos = tgt.position();
              
              // Calculate distance from node to edge line segment
              const A = nodePos.x - srcPos.x;
              const B = nodePos.y - srcPos.y;
              const C = tgtPos.x - srcPos.x;
              const D = tgtPos.y - srcPos.y;
              
              const dot = A * C + B * D;
              const lenSq = C * C + D * D;
              let param = -1;
              
              if (lenSq !== 0) param = dot / lenSq;
              
              let xx, yy;
              if (param < 0) {
                xx = srcPos.x;
                yy = srcPos.y;
              } else if (param > 1) {
                xx = tgtPos.x;
                yy = tgtPos.y;
              } else {
                xx = srcPos.x + param * C;
                yy = srcPos.y + param * D;
              }
              
              const dx = nodePos.x - xx;
              const dy = nodePos.y - yy;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Check if there's a collision and track the closest one
              if (distance < minSeparation && distance < closestDistance) {
                closestDistance = distance;
                closestCollision = {
                  edge: edge,
                  closestPoint: { x: xx, y: yy },
                  distance: distance
                };
              }
            });
            
            // Fix the closest collision for this node
            if (closestCollision) {
              const { closestPoint } = closestCollision;
              
              // Calculate push direction (away from edge)
              const dx = nodePos.x - closestPoint.x;
              const dy = nodePos.y - closestPoint.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist > 0) {
                // Normalize and scale the push vector
                const pushDistance = minSeparation - dist + 5; // Add 5px buffer
                const pushX = (dx / dist) * pushDistance;
                const pushY = (dy / dist) * pushDistance;
                
                // Apply the push
                node.position({
                  x: nodePos.x + pushX,
                  y: nodePos.y + pushY
                });
                
                collisionsFixed++;
              }
            }
          });
          
          console.log(`Fixed ${collisionsFixed} node/edge collisions`);
        };
        
        // Function to fix specific edge crossings by repositioning nodes
        fixSpecificCrossings = () => {
          if (!cy) return;
          
          let crossingsFixed = 0;
          const processed = new Set();
          
          // Helper function to count all crossings
          const countAllCrossings = () => {
            let total = 0;
            const allEdges = cy.edges();
            allEdges.forEach((e1, i) => {
              allEdges.forEach((e2, j) => {
                if (i >= j) return;
                
                const src1 = e1.source().position();
                const tgt1 = e1.target().position();
                const src2 = e2.source().position();
                const tgt2 = e2.target().position();
                
                if (e1.source().id() === e2.source().id() || e1.source().id() === e2.target().id() ||
                    e1.target().id() === e2.source().id() || e1.target().id() === e2.target().id()) {
                  return;
                }
                
                if (edgesIntersect(src1, tgt1, src2, tgt2)) {
                  total++;
                }
              });
            });
            return total;
          };
          
          // Count initial crossings
          const initialCrossings = countAllCrossings();
          console.log(`fixSpecificCrossings: Starting with ${initialCrossings} total crossings`);
          
          if (initialCrossings === 0) {
            console.log('No crossings to fix - exiting early');
            return;
          }
          
          // Try swapping endpoints of crossing edges
          console.log('Trying to swap endpoints of crossing edges...');
          let totalSwapsChecked = 0;
          let swapsMade = 0;
          const maxSwapsPerRun = 10; // Limit swaps per run to avoid infinite loops
          
          while (swapsMade < maxSwapsPerRun) {
            let bestSwap = null;
            let bestReduction = 0;
            const currentCrossings = countAllCrossings();
            
            if (currentCrossings === 0) {
              console.log('All crossings eliminated!');
              break;
            }
            
            // Recalculate crossing pairs each iteration (they change after swaps!)
            const crossingPairs = [];
            const allEdges = cy.edges();
            
            allEdges.forEach((e1, i) => {
              allEdges.forEach((e2, j) => {
                if (i >= j) return; // Avoid duplicates
                
                const src1 = e1.source();
                const tgt1 = e1.target();
                const src2 = e2.source();
                const tgt2 = e2.target();
                
                // Skip if edges share a node
                if (src1.id() === src2.id() || src1.id() === tgt2.id() ||
                    tgt1.id() === src2.id() || tgt1.id() === tgt2.id()) {
                  return;
                }
                
                const src1Pos = src1.position();
                const tgt1Pos = tgt1.position();
                const src2Pos = src2.position();
                const tgt2Pos = tgt2.position();
                
                if (edgesIntersect(src1Pos, tgt1Pos, src2Pos, tgt2Pos)) {
                  crossingPairs.push({
                    edge1: e1,
                    edge2: e2,
                    nodes: [src1, tgt1, src2, tgt2],
                    nodeIds: [src1.id(), tgt1.id(), src2.id(), tgt2.id()]
                  });
                }
              });
            });
            
            console.log(`Iteration ${swapsMade + 1}: Found ${crossingPairs.length} crossing edge pairs`);
            
            if (crossingPairs.length === 0) {
              console.log('No more crossing edges found!');
              break;
            }
            
            // For each crossing pair, try all 6 possible swaps of the 4 endpoints
            for (const crossing of crossingPairs) {
              if (crossing.nodes.some(n => processed.has(n.id()))) continue;
              
              const [src1, tgt1, src2, tgt2] = crossing.nodes;
              
              // Generate all possible pairs from the 4 nodes
              const nodePairs = [
                [src1, src2], // Swap sources
                [src1, tgt2], // Swap src1 with tgt2
                [tgt1, src2], // Swap tgt1 with src2
                [tgt1, tgt2], // Swap targets
                [src1, tgt1], // Swap nodes of edge1 (shouldn't help but check anyway)
                [src2, tgt2]  // Swap nodes of edge2 (shouldn't help but check anyway)
              ];
              
              for (const [node1, node2] of nodePairs) {
                if (processed.has(node1.id()) || processed.has(node2.id())) continue;
                if (node1.degree() > 10 || node2.degree() > 10) continue;
                
                const pos1 = {...node1.position()};
                const pos2 = {...node2.position()};
                totalSwapsChecked++;
                
                // Try the swap
                node1.position(pos2);
                node2.position(pos1);
                
                const newCrossings = countAllCrossings();
                const reduction = currentCrossings - newCrossings;
                
                // Keep track of the best swap
                if (reduction > bestReduction) {
                  bestReduction = reduction;
                  bestSwap = {
                    node1: node1,
                    node2: node2,
                    pos1: pos1,
                    pos2: pos2,
                    reduction: reduction,
                    newCrossings: newCrossings
                  };
                  console.log(`  Found beneficial swap: ${node1.id()} <-> ${node2.id()} reduces ${reduction} crossings`);
                }
                
                // Revert the swap for now
                node1.position(pos1);
                node2.position(pos2);
              }
            }
            
            // If no good swaps found in crossing pairs, try all pairs as fallback
            if (!bestSwap) {
              console.log('No beneficial swaps found in crossing pairs, trying all node pairs...');
              const allNodes = cy.nodes();
              
              for (let i = 0; i < allNodes.length; i++) {
                const node1 = allNodes[i];
                if (processed.has(node1.id())) continue;
                if (node1.degree() > 10) continue;
                
                const pos1 = {...node1.position()};
                
                for (let j = i + 1; j < allNodes.length; j++) {
                  const node2 = allNodes[j];
                  if (processed.has(node2.id())) continue;
                  if (node2.degree() > 10) continue;
                  
                  const pos2 = {...node2.position()};
                  totalSwapsChecked++;
                  
                  // Try the swap
                  node1.position(pos2);
                  node2.position(pos1);
                  
                  const newCrossings = countAllCrossings();
                  const reduction = currentCrossings - newCrossings;
                  
                  // Keep track of the best swap
                  if (reduction > bestReduction) {
                    bestReduction = reduction;
                    bestSwap = {
                      node1: node1,
                      node2: node2,
                      pos1: pos1,
                      pos2: pos2,
                      reduction: reduction,
                      newCrossings: newCrossings
                    };
                  }
                  
                  // Revert the swap for now
                  node1.position(pos1);
                  node2.position(pos2);
                }
              }
            }
            
            // Apply the best swap if we found one
            if (bestSwap && bestReduction > 0) {
              bestSwap.node1.position(bestSwap.pos2);
              bestSwap.node2.position(bestSwap.pos1);
              processed.add(bestSwap.node1.id());
              processed.add(bestSwap.node2.id());
              crossingsFixed += bestReduction;
              swapsMade++;
              console.log(`Swap ${swapsMade}: ${bestSwap.node1.id()} <-> ${bestSwap.node2.id()}, reduced ${bestReduction} crossings (${currentCrossings} -> ${bestSwap.newCrossings})`);
            } else {
              console.log(`No beneficial swaps found after checking ${totalSwapsChecked} combinations`);
              break;
            }
          }
          
          console.log(`Swap search complete: Made ${swapsMade} swaps, checked ${totalSwapsChecked} combinations, fixed ${crossingsFixed} crossings`);
          
          // Return the number of crossings fixed
          return crossingsFixed;
        };
        
        // Function to untangle knots by contracting then expanding
        untangleKnots = async () => {
          if (!cy) return;
          
          console.log('Attempting to untangle knots...');
          
          // Save initial positions in case we make things worse
          const beforePositions = {};
          cy.nodes().forEach(node => {
            beforePositions[node.id()] = {...node.position()};
          });
          
          const beforeCrossings = countCrossings(cy);
          const beforeCollisions = countNodeEdgeCollisions(cy);
          
          // Phase 1: Contract - pull everything tight together
          console.log('  Phase 1: Contracting nodes...');
          await new Promise(resolve => {
            cy.layout({
              name: 'fcose',
              quality: 'default',
              numIter: 500,
              animate: false,
              randomize: false,
              idealEdgeLength: 30,    // Very short edges
              nodeRepulsion: 500,     // Weak repulsion
              edgeElasticity: 0.8,    // Strong springs
              gravity: 5,             // Strong gravity to center
              gravityRange: 0.8,
              componentSpacing: 10
            }).run();
            
            cy.one('layoutstop', () => {
              setTimeout(resolve, 100);
            });
          });
          
          // Phase 2: Expand - let it breathe and spread out
          console.log('  Phase 2: Expanding layout...');
          await new Promise(resolve => {
            cy.layout({
              name: 'fcose',
              quality: 'proof',
              numIter: 1000,
              animate: false,
              randomize: false,
              idealEdgeLength: edge => {
                const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
                return Math.max(minNodeDist * 2, 80);
              },
              nodeRepulsion: node => {
                const nodeRepulsion = parseInt(document.getElementById('nodeRepulsion').value, 10) || 16000;
                return nodeRepulsion;
              },
              edgeElasticity: 0.45,
              gravity: 0.5,
              gravityRange: 0.8
            }).run();
            
            cy.one('layoutstop', () => {
              setTimeout(resolve, 100);
            });
          });
          
          const afterCrossings = countCrossings(cy);
          const afterCollisions = countNodeEdgeCollisions(cy);
          
          console.log(`  Untangle result: ${beforeCrossings}→${afterCrossings} crossings, ${beforeCollisions}→${afterCollisions} collisions`);
          
          // Restore if we made things worse
          if (afterCrossings > beforeCrossings || afterCollisions > beforeCollisions * 2) {
            console.log('  Untangle made things worse, restoring positions');
            cy.nodes().forEach(node => {
              if (beforePositions[node.id()]) {
                node.position(beforePositions[node.id()]);
              }
            });
            return false;
          }
          
          return true;
        };
        
        // Old code for other passes removed - they were causing problems
        /*
          cy.nodes().forEach(node1 => {
            if (processed.has(node1.id())) return;
            if (node1.degree() > 6) return;  // Increased to allow degree-6 nodes
            
            const neighbors1 = node1.neighborhood().nodes();
            
            // Look for another node that might benefit from swapping
            cy.nodes().forEach(node2 => {
              if (node1.id() === node2.id()) return;
              if (processed.has(node2.id())) return;
              if (node2.degree() > 6) return;  // Increased to allow degree-6 nodes
              
              const neighbors2 = node2.neighborhood().nodes();
              
              // Calculate if these nodes are relatively close (potential swap candidates)
              const pos1 = node1.position();
              const pos2 = node2.position();
              const distance = Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
              
              // Debug logging for specific nodes
              if ((debugNodes.includes(node1.id()) && debugNodes.includes(node2.id()))) {
                console.log(`Checking swap: ${node1.id()} <-> ${node2.id()}, distance: ${distance.toFixed(0)}, degrees: ${node1.degree()}, ${node2.degree()}`);
              }
              
              // Only consider swapping if nodes are within reasonable distance
              if (distance > 1200) {  // Increased distance threshold for more aggressive swapping
                if ((node1.id() === '1078' && node2.id() === '386') || (node1.id() === '386' && node2.id() === '1078') ||
                    (node1.id() === '4545' && node2.id() === '3581') || (node1.id() === '3581' && node2.id() === '4545') ||
                    (node1.id() === '1078' && node2.id() === '2409') || (node1.id() === '2409' && node2.id() === '1078') ||
                    (node1.id() === '2409' && node2.id() === '3581') || (node1.id() === '3581' && node2.id() === '2409')) {
                  console.log(`SKIPPING ${node1.id()} <-> ${node2.id()} due to distance: ${distance.toFixed(0)} > 800`);
                }
                return;
              }
              
              // Check if they share a common neighbor OR if swapping might help
              let hasCommonNeighbor = false;
              neighbors1.forEach(n1 => {
                if (neighbors2.some(n2 => n2.id() === n1.id())) {
                  hasCommonNeighbor = true;
                }
              });
              
              // Log debug info for specific pairs
              if ((node1.id() === '1078' && node2.id() === '386') || (node1.id() === '386' && node2.id() === '1078') ||
                  (node1.id() === '4545' && node2.id() === '3581') || (node1.id() === '3581' && node2.id() === '4545') ||
                  (node1.id() === '1078' && node2.id() === '2409') || (node1.id() === '2409' && node2.id() === '1078') ||
                  (node1.id() === '1078' && node2.id() === '4545') || (node1.id() === '4545' && node2.id() === '1078') ||
                  (node1.id() === '2409' && node2.id() === '3581') || (node1.id() === '3581' && node2.id() === '2409') ||
                  (node1.id() === '2031' && node2.id() === '1078') || (node1.id() === '1078' && node2.id() === '2031')) {
                console.log(`  ${node1.id()} <-> ${node2.id()}: hasCommonNeighbor=${hasCommonNeighbor}, distance=${distance.toFixed(0)}`);
              }
              
              // Also consider nodes that don't share neighbors but are within range
              if (hasCommonNeighbor || distance < 1200) {  // Increased distance threshold
                // Count current crossings for edges connected to these nodes
                let currentCrossings = 0;
                const edges1 = node1.connectedEdges();
                const edges2 = node2.connectedEdges();
                
                // Get ALL edges for complete crossing count
                const allEdges = cy.edges();
                
                // Count ALL crossings in the current state (not just those involving node1/node2)
                let totalCurrentCrossings = 0;
                allEdges.forEach((e1, i) => {
                  allEdges.forEach((e2, j) => {
                    if (i >= j) return; // Avoid counting same pair twice
                    
                    const src1 = e1.source().position();
                    const tgt1 = e1.target().position();
                    const src2 = e2.source().position();
                    const tgt2 = e2.target().position();
                    
                    // Skip if edges share a node
                    if (e1.source().id() === e2.source().id() || e1.source().id() === e2.target().id() ||
                        e1.target().id() === e2.source().id() || e1.target().id() === e2.target().id()) {
                      return;
                    }
                    
                    if (edgesIntersect(src1, tgt1, src2, tgt2)) {
                      totalCurrentCrossings++;
                    }
                  });
                });
                
                currentCrossings = totalCurrentCrossings;
                
                // Debug logging for specific pairs
                if ((node1.id() === '1078' && node2.id() === '386') || (node1.id() === '386' && node2.id() === '1078') ||
                    (node1.id() === '4545' && node2.id() === '3581') || (node1.id() === '3581' && node2.id() === '4545') ||
                    (node1.id() === '1078' && node2.id() === '2409') || (node1.id() === '2409' && node2.id() === '1078') ||
                    (node1.id() === '1078' && node2.id() === '4545') || (node1.id() === '4545' && node2.id() === '1078') ||
                    (node1.id() === '2409' && node2.id() === '3581') || (node1.id() === '3581' && node2.id() === '2409') ||
                    (node1.id() === '2031' && node2.id() === '1078') || (node1.id() === '1078' && node2.id() === '2031')) {
                  console.log(`  Current TOTAL crossings for ${node1.id()} <-> ${node2.id()}: ${currentCrossings}`);
                }
                
                // Try swapping positions
                const pos1 = {...node1.position()};
                const pos2 = {...node2.position()};
                
                // Validate positions before swapping
                if (isNaN(pos1.x) || isNaN(pos1.y) || isNaN(pos2.x) || isNaN(pos2.y)) {
                  console.warn(`Invalid positions for nodes ${node1.id()} or ${node2.id()}, skipping swap`);
                  return;
                }
                
                node1.position(pos2);
                node2.position(pos1);
                
                // Count ALL crossings after swap (not just those involving node1/node2)
                let totalSwappedCrossings = 0;
                allEdges.forEach((e1, i) => {
                  allEdges.forEach((e2, j) => {
                    if (i >= j) return; // Avoid counting same pair twice
                    
                    const src1 = e1.source().position();
                    const tgt1 = e1.target().position();
                    const src2 = e2.source().position();
                    const tgt2 = e2.target().position();
                    
                    // Skip if edges share a node
                    if (e1.source().id() === e2.source().id() || e1.source().id() === e2.target().id() ||
                        e1.target().id() === e2.source().id() || e1.target().id() === e2.target().id()) {
                      return;
                    }
                    
                    if (edgesIntersect(src1, tgt1, src2, tgt2)) {
                      totalSwappedCrossings++;
                    }
                  });
                });
                
                let swappedCrossings = totalSwappedCrossings;
                
                // Debug logging for specific pairs
                if ((node1.id() === '1078' && node2.id() === '386') || (node1.id() === '386' && node2.id() === '1078') ||
                    (node1.id() === '4545' && node2.id() === '3581') || (node1.id() === '3581' && node2.id() === '4545') ||
                    (node1.id() === '1078' && node2.id() === '2409') || (node1.id() === '2409' && node2.id() === '1078') ||
                    (node1.id() === '1078' && node2.id() === '4545') || (node1.id() === '4545' && node2.id() === '1078') ||
                    (node1.id() === '2409' && node2.id() === '3581') || (node1.id() === '3581' && node2.id() === '2409') ||
                    (node1.id() === '2031' && node2.id() === '1078') || (node1.id() === '1078' && node2.id() === '2031')) {
                  console.log(`  Swapped TOTAL crossings for ${node1.id()} <-> ${node2.id()}: ${swappedCrossings}`);
                  console.log(`  Decision: ${swappedCrossings < currentCrossings ? 'SWAP' : 'NO SWAP'} (${currentCrossings} -> ${swappedCrossings})`);
                }
                
                // Keep swap if it reduces crossings, otherwise revert
                if (swappedCrossings < currentCrossings) {
                  crossingsFixed += currentCrossings - swappedCrossings;
                  console.log(`Swapped nodes ${node1.id()} and ${node2.id()}, reduced ${currentCrossings - swappedCrossings} crossings`);
                  processed.add(node1.id());
                  processed.add(node2.id());
                } else {
                  // Revert swap
                  node1.position(pos1);
                  node2.position(pos2);
                  
                  // Log why we didn't swap if they were close candidates or debug nodes
                  if (distance < 150 || (debugNodes.includes(node1.id()) && debugNodes.includes(node2.id()))) {
                    console.log(`Did not swap ${node1.id()} and ${node2.id()} (distance: ${distance.toFixed(0)}, crossings: ${currentCrossings} -> ${swappedCrossings})`);
                  }
                }
              }
            });
          });
          
          // Second pass: For each node, check if moving it reduces crossings
          cy.nodes().forEach(node => {
            const degree = node.degree();
            if (degree > 6) return; // Allow up to degree-6 nodes
            
            const nodePos = node.position();
            const neighbors = node.neighborhood().nodes();
            
            // For degree-1 nodes (leaf nodes), try different positions around their neighbor
            if (degree === 1 && neighbors.length === 1) {
              const neighbor = neighbors[0];
              const neighborPos = neighbor.position();
              
              // Count current crossings involving this node's edge
              let currentCrossings = 0;
              const nodeEdges = node.connectedEdges();
              
              cy.edges().forEach(edge => {
                if (nodeEdges.some(e => e.id() === edge.id())) return;
                
                // Check if this edge crosses with the node's edge
                const src1 = nodeEdges[0].source().position();
                const tgt1 = nodeEdges[0].target().position();
                const src2 = edge.source().position();
                const tgt2 = edge.target().position();
                
                if (edgesIntersect(src1, tgt1, src2, tgt2)) {
                  currentCrossings++;
                }
              });
              
              if (currentCrossings > 0) {
                // Try positions in a circle around the neighbor
                const angles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, -3*Math.PI/4, -Math.PI/2, -Math.PI/4];
                const radius = 100;
                let bestPos = nodePos;
                let bestCrossings = currentCrossings;
                
                angles.forEach(angle => {
                  const testX = neighborPos.x + radius * Math.cos(angle);
                  const testY = neighborPos.y + radius * Math.sin(angle);
                  
                  // Count crossings at this test position
                  let testCrossings = 0;
                  cy.edges().forEach(edge => {
                    if (nodeEdges.some(e => e.id() === edge.id())) return;
                    
                    const src2 = edge.source().position();
                    const tgt2 = edge.target().position();
                    
                    if (edgesIntersect(
                      {x: testX, y: testY},
                      neighborPos,
                      src2,
                      tgt2
                    )) {
                      testCrossings++;
                    }
                  });
                  
                  if (testCrossings < bestCrossings) {
                    bestCrossings = testCrossings;
                    bestPos = {x: testX, y: testY};
                  }
                });
                
                if (bestCrossings < currentCrossings) {
                  node.position(bestPos);
                  crossingsFixed += currentCrossings - bestCrossings;
                  console.log(`Moved node ${node.id()} to reduce ${currentCrossings - bestCrossings} crossings`);
                }
              }
            }
            
            // For degree-2 through degree-6 nodes, check if repositioning helps
            if (degree >= 2 && degree <= 6 && neighbors.length === degree) {
              // Calculate center of neighbors
              let centerX = 0, centerY = 0;
              neighbors.forEach(n => {
                const pos = n.position();
                centerX += pos.x;
                centerY += pos.y;
              });
              centerX /= neighbors.length;
              centerY /= neighbors.length;
              
              // Generate test positions around the center and at various distances
              const testPositions = [];
              const currentDist = Math.sqrt(Math.pow(nodePos.x - centerX, 2) + Math.pow(nodePos.y - centerY, 2));
              
              // Try positions in a circle around the center of neighbors
              const angles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, -3*Math.PI/4, -Math.PI/2, -Math.PI/4];
              const distances = [currentDist * 0.7, currentDist, currentDist * 1.3];
              
              angles.forEach(angle => {
                distances.forEach(dist => {
                  testPositions.push({
                    x: centerX + dist * Math.cos(angle),
                    y: centerY + dist * Math.sin(angle)
                  });
                });
              });
              
              // Also try positions near each neighbor
              neighbors.forEach(neighbor => {
                const nPos = neighbor.position();
                const offsetDist = 80;
                angles.slice(0, 4).forEach(angle => {
                  testPositions.push({
                    x: nPos.x + offsetDist * Math.cos(angle),
                    y: nPos.y + offsetDist * Math.sin(angle)
                  });
                });
              });
                
              // Count crossings at current position
              let currentCrossings = 0;
              const nodeEdges = node.connectedEdges();
              
              cy.edges().forEach(edge => {
                if (nodeEdges.some(e => e.id() === edge.id())) return;
                
                nodeEdges.forEach(nodeEdge => {
                  const src1 = nodeEdge.source().position();
                  const tgt1 = nodeEdge.target().position();
                  const src2 = edge.source().position();
                  const tgt2 = edge.target().position();
                  
                  if (edgesIntersect(src1, tgt1, src2, tgt2)) {
                    currentCrossings++;
                  }
                });
              });
              
              // Test all positions
              let bestPos = nodePos;
              let bestCrossings = currentCrossings;
              
              testPositions.forEach(testPos => {
                // Validate test position
                if (isNaN(testPos.x) || isNaN(testPos.y)) return;
                
                // Temporarily move node to test position
                const originalPos = node.position();
                node.position(testPos);
                
                // Count crossings at test position
                let testCrossings = 0;
                cy.edges().forEach(edge => {
                  if (nodeEdges.some(e => e.id() === edge.id())) return;
                  
                  nodeEdges.forEach(nodeEdge => {
                    const src1 = nodeEdge.source().position();
                    const tgt1 = nodeEdge.target().position();
                    const src2 = edge.source().position();
                    const tgt2 = edge.target().position();
                    
                    if (edgesIntersect(src1, tgt1, src2, tgt2)) {
                      testCrossings++;
                    }
                  });
                });
                
                // Restore original position
                node.position(originalPos);
                
                if (testCrossings < bestCrossings) {
                  bestCrossings = testCrossings;
                  bestPos = {...testPos};
                }
              });
              
              if (bestCrossings < currentCrossings) {
                node.position(bestPos);
                crossingsFixed += currentCrossings - bestCrossings;
                console.log(`Moved node ${node.id()} to new position, reduced ${currentCrossings - bestCrossings} crossings`);
              }
            }
          });
          
          // Third pass: For nodes with common neighbors, try repositioning around the neighbor
          cy.nodes().forEach(centerNode => {
            const centerNeighbors = centerNode.neighborhood().nodes();
            if (centerNeighbors.length < 2) return;
            
            // Group neighbors by their relative positions
            const neighborsByAngle = centerNeighbors.map(n => {
              const pos = n.position();
              const centerPos = centerNode.position();
              const angle = Math.atan2(pos.y - centerPos.y, pos.x - centerPos.x);
              return { node: n, angle: angle };
            }).sort((a, b) => a.angle - b.angle);
            
            // Check for neighbors that are close in angle and could be reordered
            for (let i = 0; i < neighborsByAngle.length; i++) {
              const next = (i + 1) % neighborsByAngle.length;
              const n1 = neighborsByAngle[i].node;
              const n2 = neighborsByAngle[next].node;
              
              // Only consider if both have degree <= 5
              if (n1.degree() > 5 || n2.degree() > 5) continue;
              
              // Count crossings before swap
              let beforeCrossings = 0;
              const edges1 = n1.connectedEdges();
              const edges2 = n2.connectedEdges();
              
              cy.edges().forEach(edge => {
                if (edges1.some(e => e.id() === edge.id()) || edges2.some(e => e.id() === edge.id())) return;
                
                edges1.forEach(e1 => {
                  if (edgesIntersect(
                    e1.source().position(),
                    e1.target().position(),
                    edge.source().position(),
                    edge.target().position()
                  )) {
                    beforeCrossings++;
                  }
                });
                
                edges2.forEach(e2 => {
                  if (edgesIntersect(
                    e2.source().position(),
                    e2.target().position(),
                    edge.source().position(),
                    edge.target().position()
                  )) {
                    beforeCrossings++;
                  }
                });
              });
              
              // Try rotating their positions around the center
              const centerPos = centerNode.position();
              const pos1 = {...n1.position()};
              const pos2 = {...n2.position()};
              
              // Calculate new positions (rotate around center)
              const dist1 = Math.sqrt(Math.pow(pos1.x - centerPos.x, 2) + Math.pow(pos1.y - centerPos.y, 2));
              const dist2 = Math.sqrt(Math.pow(pos2.x - centerPos.x, 2) + Math.pow(pos2.y - centerPos.y, 2));
              
              // Skip if distances are zero or invalid
              if (dist1 === 0 || dist2 === 0 || isNaN(dist1) || isNaN(dist2)) {
                continue;
              }
              
              const newPos1 = {
                x: centerPos.x + dist1 * Math.cos(neighborsByAngle[next].angle),
                y: centerPos.y + dist1 * Math.sin(neighborsByAngle[next].angle)
              };
              const newPos2 = {
                x: centerPos.x + dist2 * Math.cos(neighborsByAngle[i].angle),
                y: centerPos.y + dist2 * Math.sin(neighborsByAngle[i].angle)
              };
              
              // Validate new positions
              if (isNaN(newPos1.x) || isNaN(newPos1.y) || isNaN(newPos2.x) || isNaN(newPos2.y)) {
                console.warn(`Invalid new positions for nodes ${n1.id()} or ${n2.id()}, skipping rotation`);
                continue;
              }
              
              n1.position(newPos1);
              n2.position(newPos2);
              
              // Count crossings after repositioning
              let afterCrossings = 0;
              cy.edges().forEach(edge => {
                if (edges1.some(e => e.id() === edge.id()) || edges2.some(e => e.id() === edge.id())) return;
                
                edges1.forEach(e1 => {
                  if (edgesIntersect(
                    e1.source().position(),
                    e1.target().position(),
                    edge.source().position(),
                    edge.target().position()
                  )) {
                    afterCrossings++;
                  }
                });
                
                edges2.forEach(e2 => {
                  if (edgesIntersect(
                    e2.source().position(),
                    e2.target().position(),
                    edge.source().position(),
                    edge.target().position()
                  )) {
                    afterCrossings++;
                  }
                });
              });
              
              // Keep change if it helps, otherwise revert
              if (afterCrossings < beforeCrossings) {
                crossingsFixed += beforeCrossings - afterCrossings;
                console.log(`Rotated nodes ${n1.id()} and ${n2.id()} around ${centerNode.id()}, reduced ${beforeCrossings - afterCrossings} crossings`);
              } else {
                // Revert
                n1.position(pos1);
                n2.position(pos2);
              }
            }
          });
          
          // Final validation: ensure all nodes have valid positions
          let invalidNodes = 0;
          cy.nodes().forEach(node => {
            const pos = node.position();
            if (isNaN(pos.x) || isNaN(pos.y) || 
                Math.abs(pos.x) > 100000 || Math.abs(pos.y) > 100000) {
              console.error(`Node ${node.id()} has invalid position:`, pos);
              // Restore original position
              if (originalPositions[node.id()]) {
                node.position(originalPositions[node.id()]);
                invalidNodes++;
              }
            }
          });
          
          if (invalidNodes > 0) {
            console.warn(`Restored ${invalidNodes} nodes to original positions due to invalid coordinates`);
          }
          
          // Fourth pass: Target specific edges with multiple crossings
          cy.edges().forEach(edge => {
            const src = edge.source();
            const tgt = edge.target();
            
            // Skip if nodes have very high degree
            if (src.degree() > 6 || tgt.degree() > 6) return;
            
            // Count how many edges this edge crosses
            let edgeCrossings = 0;
            const srcPos = src.position();
            const tgtPos = tgt.position();
            
            cy.edges().forEach(otherEdge => {
              if (edge.id() === otherEdge.id()) return;
              
              // Skip if edges share a node
              if (src.id() === otherEdge.source().id() || src.id() === otherEdge.target().id() ||
                  tgt.id() === otherEdge.source().id() || tgt.id() === otherEdge.target().id()) {
                return;
              }
              
              const otherSrcPos = otherEdge.source().position();
              const otherTgtPos = otherEdge.target().position();
              
              if (edgesIntersect(srcPos, tgtPos, otherSrcPos, otherTgtPos)) {
                edgeCrossings++;
              }
            });
            
            // Debug specific edges
            if ((src.id() === '4845' && tgt.id() === '3581') || (src.id() === '3581' && tgt.id() === '4845') ||
                (src.id() === '2409' && tgt.id() === '3581') || (src.id() === '3581' && tgt.id() === '2409') ||
                (src.id() === '2031' && tgt.id() === '1078') || (src.id() === '1078' && tgt.id() === '2031')) {
              console.log(`DEBUG: Edge ${src.id()}-${tgt.id()} has ${edgeCrossings} crossings`);
            }
            
            // If this edge has 2+ crossings, try to fix it
            if (edgeCrossings >= 2) {
              console.log(`Edge ${src.id()}-${tgt.id()} has ${edgeCrossings} crossings, attempting to fix...`);
              
              // Try moving the source node to different positions
              const originalSrcPos = {...srcPos};
              let bestSrcPos = originalSrcPos;
              let bestCrossings = edgeCrossings;
              
              // Test positions around the target
              const angles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, -3*Math.PI/4, -Math.PI/2, -Math.PI/4];
              const distance = Math.sqrt(Math.pow(srcPos.x - tgtPos.x, 2) + Math.pow(srcPos.y - tgtPos.y, 2));
              
              angles.forEach(angle => {
                const testPos = {
                  x: tgtPos.x + distance * Math.cos(angle),
                  y: tgtPos.y + distance * Math.sin(angle)
                };
                
                // Temporarily move source to test position
                src.position(testPos);
                
                // Count crossings with this position
                let testCrossings = 0;
                cy.edges().forEach(otherEdge => {
                  if (edge.id() === otherEdge.id()) return;
                  
                  if (src.id() === otherEdge.source().id() || src.id() === otherEdge.target().id() ||
                      tgt.id() === otherEdge.source().id() || tgt.id() === otherEdge.target().id()) {
                    return;
                  }
                  
                  const newSrcPos = src.position();
                  const otherSrcPos = otherEdge.source().position();
                  const otherTgtPos = otherEdge.target().position();
                  
                  if (edgesIntersect(newSrcPos, tgtPos, otherSrcPos, otherTgtPos)) {
                    testCrossings++;
                  }
                });
                
                if (testCrossings < bestCrossings) {
                  bestCrossings = testCrossings;
                  bestSrcPos = {...testPos};
                }
              });
              
              // Apply best position
              if (bestCrossings < edgeCrossings) {
                src.position(bestSrcPos);
                crossingsFixed += edgeCrossings - bestCrossings;
                console.log(`  Reduced crossings for edge ${src.id()}-${tgt.id()} from ${edgeCrossings} to ${bestCrossings}`);
              } else {
                src.position(originalSrcPos);
              }
            }
          });
          
          // Removed - this was part of the problematic extra passes
          */
        
        // Helper function to check if two line segments intersect
        function edgesIntersect(p1, p2, p3, p4) {
          const ccw = (A, B, C) => {
            return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
          };
          
          return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
        }
        
        
        // Now run the layout after event handler is set up
        console.log('Starting layout...');
        cy.layout(layoutOptions).run();
        
        // Update node count
        const nodeCountEl = document.getElementById('nodeCount');
        if (nodeCountEl) nodeCountEl.textContent = String(nodes.length);
      }

      // --- UI wiring ---
      const jsonEl = document.getElementById('json');
      const centerEl = document.getElementById('center');
      const hopsEl = document.getElementById('hops');
      const useWorldEl = document.getElementById('useWorld');

      // Cache player name and world data
      let savedCharacter = null;
      let worldCache = null; // {dirAdj, undAdj, portMap}

      async function loadWorldData() {
        if (worldCache) return worldCache;
        const [uRes, cRes] = await Promise.all([
          fetch('world-data/universe_structure.json'),
          fetch('world-data/sector_contents.json').catch(()=>null)
        ]);
        if (!uRes.ok) throw new Error('Could not load world-data/universe_structure.json');
        const univ = await uRes.json();
        let contents = null;
        if (cRes && cRes.ok) contents = await cRes.json();
        const dir = new Map();
        for (const s of univ.sectors) dir.set(s.id, s.warps.map(w=>w.to));
        const und = new Map();
        for (const [sid, outs] of dir) {
          if (!und.has(sid)) und.set(sid, new Set());
          for (const t of outs) {
            if (!und.has(t)) und.set(t, new Set());
            und.get(sid).add(t); und.get(t).add(sid);
          }
        }
        const portMap = new Map();
        if (contents) for (const s of contents.sectors) portMap.set(s.id, s.port && s.port.code ? s.port.code : null);
        worldCache = { dirAdj: dir, undAdj: und, portMap };
        return worldCache;
      }

      function buildLocalFromWorld(centerId, hops, world) {
        const dist = new Map([[centerId,0]]);
        const q = [centerId];
        while (q.length) {
          const u = q.shift();
          if (dist.get(u) >= hops) continue;
          for (const v of (world.undAdj.get(u) || [])) {
            if (!dist.has(v)) { dist.set(v, dist.get(u)+1); q.push(v); }
          }
        }
        const included = new Set(Array.from(dist.keys()));
        const node_list = [];
        for (const id of Array.from(included).sort((a,b)=>a-b)) {
          const outs = world.dirAdj.get(id) || [];
          node_list.push({ id, visited: true, port_type: world.portMap.get(id) || null, adjacent: outs.filter(t=>included.has(t)) });
        }
        return { node_list };
      }
      // Keep last rendered graph to allow re-render on knob changes
      let lastNodes = null;
      let lastCenter = null;
      const history = [];
      let histIndex = -1;
      function rerenderIfPossible(){ if (lastNodes && lastCenter !== null){ render(lastNodes, lastCenter); } }
      
      
      // Re-run layout button
      const relayoutBtn = document.getElementById('relayoutBtn');
      if (relayoutBtn) relayoutBtn.addEventListener('click', rerenderIfPossible);
      
      // Optimize button - run multiple attempts and pick best
      const optimizeBtn = document.getElementById('optimizeBtn');
      if (optimizeBtn) {
        optimizeBtn.addEventListener('click', async () => {
          if (!lastNodes || lastCenter === null) return;
          
          optimizeBtn.disabled = true;
          optimizeBtn.textContent = 'Optimizing...';
          
          // Function to count edge crossings
          function countCrossings(cyInstance) {
            let crossings = 0;
            const edges = cyInstance.edges();
            
            for (let i = 0; i < edges.length; i++) {
              for (let j = i + 1; j < edges.length; j++) {
                const e1 = edges[i];
                const e2 = edges[j];
                
                // Skip if edges share a node
                if (e1.source().id() === e2.source().id() || 
                    e1.source().id() === e2.target().id() ||
                    e1.target().id() === e2.source().id() ||
                    e1.target().id() === e2.target().id()) {
                  continue;
                }
                
                // Check if edges intersect
                const p1 = e1.source().position();
                const p2 = e1.target().position();
                const p3 = e2.source().position();
                const p4 = e2.target().position();
                
                // Line segment intersection test
                const ccw = (A, B, C) => {
                  return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
                };
                
                if (ccw(p1, p3, p4) !== ccw(p2, p3, p4) && 
                    ccw(p1, p2, p3) !== ccw(p1, p2, p4)) {
                  crossings++;
                }
              }
            }
            
            return crossings;
          }
          
          // Function to count node/edge collisions
          function countNodeEdgeCollisions(cyInstance, verbose = false) {
            let collisions = 0;
            const collisionDetails = [];
            const minDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
            const nodeRadius = 20; // Node radius plus label space
            
            cyInstance.edges().forEach(edge => {
              const src = edge.source();
              const tgt = edge.target();
              const srcPos = src.position();
              const tgtPos = tgt.position();
              
              cyInstance.nodes().forEach(node => {
                if (node.id() !== src.id() && node.id() !== tgt.id()) {
                  const nodePos = node.position();
                  
                  // Calculate distance from point to line segment
                  const A = nodePos.x - srcPos.x;
                  const B = nodePos.y - srcPos.y;
                  const C = tgtPos.x - srcPos.x;
                  const D = tgtPos.y - srcPos.y;
                  
                  const dot = A * C + B * D;
                  const lenSq = C * C + D * D;
                  
                  if (lenSq === 0) return; // Edge has zero length
                  
                  let param = dot / lenSq;
                  
                  // Only consider the middle portion of the edge (not near endpoints)
                  if (param > 0.1 && param < 0.9) {
                    // Point on the edge closest to the node
                    const xx = srcPos.x + param * C;
                    const yy = srcPos.y + param * D;
                    
                    const dx = nodePos.x - xx;
                    const dy = nodePos.y - yy;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // If edge passes through or very close to node
                    if (distance < nodeRadius + minDist) {
                      collisions++;
                      if (verbose) {
                        collisionDetails.push({
                          node: node.id(),
                          edge: `${src.id()}-${tgt.id()}`,
                          distance: distance.toFixed(1)
                        });
                      }
                    }
                  }
                }
              });
            });
            
            if (verbose && collisionDetails.length > 0) {
              console.log(`Collision details (${collisionDetails.length} total):`);
              // Group by node
              const byNode = {};
              collisionDetails.forEach(detail => {
                if (!byNode[detail.node]) {
                  byNode[detail.node] = [];
                }
                byNode[detail.node].push(detail.edge);
              });
              
              Object.entries(byNode).forEach(([node, edges]) => {
                console.log(`  Node ${node} collides with edges: ${edges.join(', ')}`);
              });
            }
            
            return collisions;
          }
          
          // Get current layout score
          const initialCrossings = countCrossings(cy);
          const initialCollisions = countNodeEdgeCollisions(cy);
          console.log(`Starting manual optimization with ${initialCrossings} crossings, ${initialCollisions} collisions`);
          
          // Save current layout as best so far
          let bestPositions = {};
          cy.nodes().forEach(node => {
            bestPositions[node.id()] = node.position();
          });
          let bestScore = initialCrossings + initialCollisions;
          let bestCrossings = initialCrossings;
          let bestCollisions = initialCollisions;
          
          // Try up to 12 different random layouts, but stop early if perfect
          const maxAttempts = 12;
          let actualAttempts = 0;
          
          for (let attempt = 0; attempt < maxAttempts; attempt++) {
            actualAttempts++;
            optimizeBtn.textContent = `Running attempt ${attempt + 1}...`;
            
            // Re-run layout with new random seed (don't recreate entire Cytoscape)
            const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
            const nodeRepulsion = parseInt(document.getElementById('nodeRepulsion').value, 10) || 16000;
            
            const optLayoutOptions = {
              name: 'fcose',
              quality: 'proof',
              randomize: true,
              animate: false,
              fit: false,  // Don't fit during optimization attempts
              nodeDimensionsIncludeLabels: true,
              idealEdgeLength: edge => {
                const src = edge.source();
                const tgt = edge.target();
                const srcDegree = src.degree();
                const tgtDegree = tgt.degree();
                const avgDegree = (srcDegree + tgtDegree) / 2;
                return Math.max(minNodeDist * 2, Math.min(minNodeDist * 8, 80 + avgDegree * 10));
              },
              nodeRepulsion: node => nodeRepulsion * 2.0,
              nodeOverlap: minNodeDist + 15,
              numIter: 5000,  // Quick iterations for optimization
              randomizationSeed: Math.floor(Math.random() * 1000)
            };
            
            // Wait for layout to complete
            await new Promise(resolve => {
              const layout = cy.layout(optLayoutOptions);
              
              let resolved = false;
              
              // Set up timeout in case event doesn't fire
              const timeout = setTimeout(() => {
                if (!resolved) {
                  console.log('  Manual opt: Layout timeout - proceeding anyway');
                  resolved = true;
                  resolve();
                }
              }, 3000);
              
              // Listen for layout completion BEFORE running
              cy.one('layoutstop', () => {
                if (!resolved) {
                  clearTimeout(timeout);
                  resolved = true;
                  setTimeout(resolve, 100);  // Small delay for positions to stabilize
                }
              });
              
              // Actually run the layout
              try {
                layout.run();
              } catch (err) {
                console.error('  Manual opt: Error running layout:', err);
                clearTimeout(timeout);
                resolved = true;
                resolve();
              }
            });
            
            if (cy) {
              const crossings = countCrossings(cy);
              const collisions = countNodeEdgeCollisions(cy);
              const totalScore = crossings + collisions;
              console.log(`Manual optimize attempt ${attempt + 1}: ${crossings} crossings, ${collisions} collisions`);
              
              if (totalScore < bestScore) {
                bestScore = totalScore;
                bestCrossings = crossings;
                bestCollisions = collisions;
                bestPositions = {};
                cy.nodes().forEach(node => {
                  bestPositions[node.id()] = node.position();
                });
              }
              
              optimizeBtn.textContent = `Attempt ${attempt + 1} (Best: ${bestCrossings} cross, ${bestCollisions} coll)`;
              
              // If we found a perfect layout (no crossings or collisions), stop early
              if (bestScore === 0) {
                optimizeBtn.textContent = `Perfect layout found after ${actualAttempts} attempts!`;
                break;
              }
              
              // Small delay between attempts
              await new Promise(resolve => setTimeout(resolve, 100));
            }
          }
          
          // Apply best layout
          if (bestPositions && cy) {
            cy.nodes().forEach(node => {
              if (bestPositions[node.id()]) {
                node.position(bestPositions[node.id()]);
              }
            });
            
            // If there are still crossings, try Fix Regions iteratively
            if (bestCrossings > 0 && fixEnclosedRegions) {
              optimizeBtn.textContent = `Fixing regions...`;
              
              let previousCrossings = bestCrossings;
              let previousPositions = {...bestPositions};
              let penultimatePositions = {...bestPositions};
              let iterations = 0;
              const maxIterations = 5; // Fewer iterations in optimize mode
              
              while (iterations < maxIterations) {
                penultimatePositions = {...previousPositions};
                
                // Run fix regions
                fixEnclosedRegions();
                
                // Small layout adjustment
                await new Promise(resolve => {
                  cy.layout({
                    name: 'fcose',
                    quality: 'default',
                    numIter: 300,
                    animate: false,
                    randomize: false,
                    idealEdgeLength: edge => {
                      const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
                      return Math.max(minNodeDist * 2, 80);
                    },
                    nodeRepulsion: 5000,
                    edgeElasticity: 0.45
                  }).run();
                  setTimeout(resolve, 200);
                });
                
                const currentCrossings = countCrossings(cy);
                const currentCollisions = countNodeEdgeCollisions(cy);
                console.log(`  Manual Fix Regions iteration ${iterations + 1}: ${currentCrossings} crossings, ${currentCollisions} collisions`);
                
                // If no improvement in crossings, use penultimate and stop
                if (currentCrossings >= previousCrossings) {
                  cy.nodes().forEach(node => {
                    if (penultimatePositions[node.id()]) {
                      node.position(penultimatePositions[node.id()]);
                    }
                  });
                  bestCrossings = previousCrossings;
                  break;
                }
                
                // Save current positions
                cy.nodes().forEach(node => {
                  previousPositions[node.id()] = node.position();
                });
                
                previousCrossings = currentCrossings;
                bestCrossings = currentCrossings;
                bestCollisions = currentCollisions;
                iterations++;
              }
            }
            
            // Fit the graph to the view area
            cy.fit();
            
            // Trigger curve detection if enabled
            if (applyCurvedEdges) {
              setTimeout(applyCurvedEdges, 100);
            }
          }
          
          optimizeBtn.disabled = false;
          if (bestScore === 0) {
            optimizeBtn.textContent = `Perfect! (${actualAttempts} attempts)`;
          } else {
            optimizeBtn.textContent = `Done! ${bestCrossings} cross, ${bestCollisions} coll`;
          }
          
          setTimeout(() => {
            optimizeBtn.textContent = 'Optimize';
          }, 3000);
        });
      }
      
      // Min node distance slider
      const minNodeDistEl = document.getElementById('minNodeDist');
      const minNodeDistValEl = document.getElementById('minNodeDistVal');
      if (minNodeDistEl) {
        minNodeDistEl.addEventListener('input', () => {
          if (minNodeDistValEl) minNodeDistValEl.textContent = minNodeDistEl.value;
          rerenderIfPossible();
        });
      }
      
      // Node repulsion slider
      const nodeRepulsionEl = document.getElementById('nodeRepulsion');
      const nodeRepulsionValEl = document.getElementById('nodeRepulsionVal');
      if (nodeRepulsionEl) {
        nodeRepulsionEl.addEventListener('input', () => {
          if (nodeRepulsionValEl) nodeRepulsionValEl.textContent = nodeRepulsionEl.value;
          rerenderIfPossible();
        });
      }
      
      
      // Fix Regions button
      const fixRegionsBtn = document.getElementById('fixRegionsBtn');
      if (fixRegionsBtn) {
        const fixCrossingsBtn = document.getElementById('fixCrossingsBtn');
        
        fixCrossingsBtn.addEventListener('click', async () => {
          if (fixSpecificCrossings && cy) {
            const initialCrossings = countCrossings(cy);
            const initialCollisions = countNodeEdgeCollisions(cy);
            console.log(`Before Fix Crossings: ${initialCrossings} crossings, ${initialCollisions} collisions`);
            
            // Run Fix Crossings
            fixSpecificCrossings();
            
            let afterCrossings = countCrossings(cy);
            let afterCollisions = countNodeEdgeCollisions(cy);
            console.log(`After Fix Crossings: ${afterCrossings} crossings, ${afterCollisions} collisions`);
            
            // If Fix Crossings made things significantly worse (knot situation), try again
            // This often happens when nodes are clustered together
            if (afterCrossings > initialCrossings * 2 && afterCrossings >= 5) {
              console.log(`Detected knot (${initialCrossings}→${afterCrossings} crossings), running Fix Crossings again...`);
              fixSpecificCrossings();
              
              afterCrossings = countCrossings(cy);
              afterCollisions = countNodeEdgeCollisions(cy);
              console.log(`After second Fix Crossings: ${afterCrossings} crossings, ${afterCollisions} collisions`);
              
              // Try one more time if still bad
              if (afterCrossings > initialCrossings * 1.5 && afterCrossings >= 3) {
                console.log(`Still knotted (${afterCrossings} crossings), trying Fix Crossings once more...`);
                fixSpecificCrossings();
                
                afterCrossings = countCrossings(cy);
                afterCollisions = countNodeEdgeCollisions(cy);
                console.log(`After third Fix Crossings: ${afterCrossings} crossings, ${afterCollisions} collisions`);
              }
            }
            
            // Run Fix Regions to clean up
            if (fixEnclosedRegions) {
              console.log('Running Fix Regions to clean up after crossing fixes...');
              fixEnclosedRegions();
              
              // Small layout adjustment
              await new Promise(resolve => {
                cy.layout({
                  name: 'fcose',
                  quality: 'default',
                  numIter: 300,
                  animate: false,
                  randomize: false,
                  idealEdgeLength: edge => {
                    const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 6;
                    return Math.max(minNodeDist * 2, 80);
                  },
                  nodeRepulsion: 5000,
                  edgeElasticity: 0.45
                }).run();
                
                cy.one('layoutstop', () => {
                  setTimeout(resolve, 200);
                });
              });
              
              afterCrossings = countCrossings(cy);
              afterCollisions = countNodeEdgeCollisions(cy);
              console.log(`After Fix Regions cleanup: ${afterCrossings} crossings, ${afterCollisions} collisions`);
            }
            
            // Run collision fixing to handle node/edge overlaps
            console.log('Running collision fixing...');
            fixNodeEdgeCollisions();
            
            const finalCrossings = countCrossings(cy);
            const finalCollisions = countNodeEdgeCollisions(cy);
            console.log(`After collision fixing: ${finalCrossings} crossings, ${finalCollisions} collisions`);
            
            // Fit to view
            cy.fit();
          }
        });
        
        fixRegionsBtn.addEventListener('click', async () => {
          if (fixEnclosedRegions && cy) {
            let previousCrossings = countCrossings(cy);
            let previousCollisions = countNodeEdgeCollisions(cy);
            console.log(`Starting Fix Regions with ${previousCrossings} crossings, ${previousCollisions} collisions`);
            
            let previousPositions = {};
            let penultimatePositions = {};
            let iterations = 0;
            const maxIterations = 10;
            
            // Save initial positions
            cy.nodes().forEach(node => {
              previousPositions[node.id()] = node.position();
            });
            
            // Iterate until no improvement or max iterations
            while (iterations < maxIterations) {
              // Save positions before this iteration (these become penultimate)
              penultimatePositions = {...previousPositions};
              
              // Run fix regions
              fixEnclosedRegions();
              
              // Small layout adjustment
              await new Promise(resolve => {
                cy.layout({
                  name: 'fcose', 
                  quality: 'default',
                  numIter: 500,
                  animate: false,
                  randomize: false,
                  idealEdgeLength: edge => {
                    const minNodeDist = parseInt(document.getElementById('minNodeDist').value, 10) || 10;
                    return Math.max(minNodeDist * 2, 80);
                  },
                  nodeRepulsion: 5000,
                  edgeElasticity: 0.45
                }).run();
                setTimeout(resolve, 300);
              });
              
              const currentCrossings = countCrossings(cy);
              const currentCollisions = countNodeEdgeCollisions(cy);
              console.log(`  Standalone Fix Regions iteration ${iterations + 1}: ${currentCrossings} crossings, ${currentCollisions} collisions`);
              
              // If no improvement, stop
              if (currentCrossings >= previousCrossings) {
                // Apply penultimate positions (the ones before the last attempt)
                cy.nodes().forEach(node => {
                  if (penultimatePositions[node.id()]) {
                    node.position(penultimatePositions[node.id()]);
                  }
                });
                break;
              }
              
              // Save current positions as previous for next iteration
              cy.nodes().forEach(node => {
                previousPositions[node.id()] = node.position();
              });
              
              previousCrossings = currentCrossings;
              iterations++;
              
              // Update button text to show progress
              fixRegionsBtn.textContent = `Fixing... (${currentCrossings} crossings)`;
            }
            
            // Reset button text
            fixRegionsBtn.textContent = 'Fix Regions';
            
            // Fit to view
            cy.fit();
            
            // Apply curves if enabled
            if (document.getElementById('avoidOverlaps')?.checked && applyCurvedEdges) {
              setTimeout(applyCurvedEdges, 100);
            }
            
            return;
            
            // Old single-run code (removed)
            cy.layout({
              name: 'fcose', 
              quality: 'default',
              numIter: 1000,
              animate: false,
              randomize: false,
              idealEdgeLength: 100,
              nodeRepulsion: 8000,
              edgeElasticity: 0.3,
              gravity: 0.1
            }).run();
          }
        });
      }
      
      const capModeEl = document.getElementById('capMode'); 
      if (capModeEl) capModeEl.addEventListener('change', fetchAndRender);
      const maxNodesEl = document.getElementById('maxNodes'); 
      if (maxNodesEl) maxNodesEl.addEventListener('input', fetchAndRender);

      async function fetchAndRender(skipHistory=false){
        const centerId = parseInt(centerEl.value || '0', 10);
        const hopsInput = parseInt(hopsEl.value || '3', 10);
        const capMode = document.getElementById('capMode')?.checked;
        const maxNodes = parseInt(document.getElementById('maxNodes')?.value || '25', 10);
        try{
          if (useWorldEl.checked){
            const world = await loadWorldData();
            let hops = hopsInput;
            if (capMode){
              // BFS layer counts from center
              const q=[centerId]; const dist=new Map([[centerId,0]]);
              while(q.length){ const u=q.shift(); for(const v of (world.undAdj.get(u)||[])){ if(!dist.has(v)){ dist.set(v, (dist.get(u)||0)+1); q.push(v);} } }
              const maxLayer = Math.max(...dist.values());
              const layerCounts = Array.from({length:maxLayer+1}, (_,k)=> Array.from(dist.values()).filter(d=>d===k).length);
              let cum=0, safe=0;
              for (let k=0;k<layerCounts.length;k++){ const next=cum+layerCounts[k]; if (next>maxNodes){ break; } cum=next; safe=k; }
              hops = safe; hopsEl.value = String(hops);
            }
            const data = buildLocalFromWorld(centerId, hops, world);
            document.getElementById('json').value = JSON.stringify(data, null, 2);
            lastNodes = data.node_list || []; lastCenter = centerId; await render(lastNodes, lastCenter);
            if (!skipHistory){ history.splice(histIndex+1); history.push(centerId); histIndex = history.length-1; }
          } else {
            if (!savedCharacter) { const c = prompt('Character ID to fetch for:', 'JoePlayer'); if (!c) return; savedCharacter = c; }
            let hops = hopsInput; let finalData=null; let lastData=null; let i=0;
            if (capMode){
              while(true){
                const res = await fetch('/api/local_map', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ character_id: savedCharacter, current_sector: centerId, max_hops: i }) });
                if (!res.ok) throw new Error('HTTP '+res.status);
                const data = await res.json();
                const n = (data.node_list||[]).length;
                if (n>maxNodes || n=== (lastData? lastData.node_list.length: -1)) { finalData = lastData || data; break; }
                lastData = data; i++; if (i>12) { finalData = data; break; }
              }
              hopsEl.value = String(i>0? i-1: 0);
            } else {
              const res = await fetch('/api/local_map', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ character_id: savedCharacter, current_sector: centerId, max_hops: hops }) });
              if (!res.ok) throw new Error('HTTP '+res.status);
              finalData = await res.json();
            }
            document.getElementById('json').value = JSON.stringify(finalData, null, 2);
            lastNodes = finalData.node_list || []; lastCenter = centerId; await render(lastNodes, lastCenter);
            if (!skipHistory){ history.splice(histIndex+1); history.push(centerId); histIndex = history.length-1; }
          }
        }catch(e){ alert('Fetch failed. If opening from file:// you may hit CORS or world-data/* not served.\n\nError: '+ e.message); }
      }
      document.getElementById('fetchBtn').addEventListener('click', fetchAndRender);

      // History navigation
      document.getElementById('prevBtn').addEventListener('click', async ()=>{
        if (histIndex > 0){ histIndex--; const c = history[histIndex]; centerEl.value = String(c); await fetchAndRender(true); }
      });
      document.getElementById('nextBtn').addEventListener('click', async ()=>{
        if (histIndex+1 < history.length){ histIndex++; const c = history[histIndex]; centerEl.value = String(c); await fetchAndRender(true); }
      });
      document.getElementById('randomBtn').addEventListener('click', async ()=>{
        const c = Math.floor(Math.random()*5000); 
        centerEl.value = String(c); 
        await fetchAndRender();
      });

      // Seed with a tiny sample so the page shows something immediately
      const sample = { node_list: [
        { id: 39, visited: true, port_type: null, adjacent: [776, 286, 190] },
        { id: 776, visited: true, port_type: null, adjacent: [39, 578] },
        { id: 286, visited: false, port_type: 'SSS', adjacent: [39] },
        { id: 190, visited: true, port_type: 'STD', adjacent: [39, 199, 274] },
        { id: 199, visited: true, port_type: 'SBB', adjacent: [190, 274] },
        { id: 274, visited: false, port_type: 'SSS', adjacent: [190, 199, 174] },
        { id: 174, visited: false, port_type: null, adjacent: [274, 66] },
        { id: 66, visited: false, port_type: null, adjacent: [174, 177] },
        { id: 177, visited: false, port_type: null, adjacent: [66] }
      ]};
      document.getElementById('json').value = JSON.stringify(sample, null, 2);
      // Initial render
      (async () => { await render(sample.node_list, 39); })();
    </script>
  </body>
  </html>
